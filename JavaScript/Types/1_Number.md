# Число

Для представления чисел в JavaScript используется 64-битный формат, определяемый стандартом **IEEE 754**.

* Формат представления вещественных чисел в JavaScript позволяет точно представлять все целые числа от –9007199254740992 (–2 в степени 53) до 9007199254740992 (2 в степени 53) включительно.
Для целых значений вне этого диапазона может теряться точность в младших разрядах.

* Некоторые операции в JavaScript (такие как обращение к элементам массива по индексам и битовые операции) выполняются с 32-разрядными целыми значениями.

Число, находящееся непосредственно в программе, называется числовым литералом.

* Помимо десятичных целых литералов JavaScript распознает шестнадцатеричные значения (по основанию 16). Шестнадцатеричные литералы начинаются с последовательности символов «0x» или «0X», за которой следует строка шестнадцатеричных цифр.

* Хотя стандарт ECMAScript не поддерживает представление целых литералов в восьмеричном формате (по основанию 8), некоторые реализации JavaScript допускают подобную возможность. Восьмеричный литерал начинается с цифры 0, за которой могут следовать цифры от 0 до 7.

Например:

```` js
0377 // 3*64 + 7*8 + 7 = 255 (по ос­но­ва­нию 10)
````

В строгом (strict) режиме, определяемом стандартом ECMAScript 5, восьмеричные литералы явно
запрещены.

* Литералы вещественных чисел должны иметь десятичную точку – при определении таких литералов используется традиционный синтаксис вещественных чисел. Вещественное значение представляется как целая часть числа, за которой следуют десятичная точка и дробная часть числа. Литералы вещественных чисел могут также представляться в экспоненциальной нотации: вещественное число, за которым следует буква e (или E), а затем необязательный знак плюс или минус и целая экспонента. Такая форма записи обозначает вещественное число, умноженное на 10 в степени, определяемой значением экспоненты.

## Тип number включает несколько специальных значений

* В JavaScript имеются предопределенные глобальные переменные **Infinity** и **NaN**, хранящие значения положительной бесконечности и «не число». В стандарте ECMAScript 3 эти переменные доступны для чтения/записи и могут изменяться в программах. Стандарт ECMAScript 5 исправляет эту оплошность и требует, чтобы эти переменные были доступны только для чтения. Объект Number предоставляет альтернативные представления некоторых значений, доступные только для чтения даже в ECMAScript 3.

Например:

```` js
Infinity // Пе­ре­мен­ная, дос­туп­ная для чте­ния/за­пи­си.
Number.POSITIVE_INFINITY // То же зна­че­ние, дос­туп­ное толь­ко для чте­ния.
1/0 // То же са­мое зна­че­ние.
Number.MAX_VALUE + 1 // Это вы­ра­же­ние так­же воз­вра­ща­ет Infinity.
Number.NEGATIVE_INFINITY // Воз­вра­ща­ют от­ри­ца­тель­ную бес­ко­неч­ность.
-Infinity
-1/0
-Number.MAX_VALUE - 1
NaN // Пе­ре­мен­ная, дос­туп­ная для чте­ния/за­пи­си,
Number.NaN // Свой­ст­во, дос­туп­ное толь­ко для чте­ния, с тем же зна­че­ни­ем.
0/0 // Воз­вра­ща­ет NaN.
Number.MIN_VALUE/2 // По­те­ря зна­ча­щих раз­ря­дов: воз­вра­ща­ет 0
-Number.MIN_VALUE/2 // От­ри­ца­тель­ный ноль
-1/Infinity // Так­же от­ри­ца­тель­ный ноль
-0
````

### NaN

* любая математическая операция, у которой один из двух операндов не является числом (или значением, которое может быть интерпретировано как обычное число в десятичной или шестнадцатеричной системе), не может произвести допустимое число; вместо этого будет получено значение NaN.

NaN в действительности означает «не число» (Not A Number):

``` js
var a = 2 / "foo"; // NaN
typeof a === "number"; // true
````

* NaN — сигнальное значение представляющее особую разновидность состояний ошибок в числовом множестве.
* NaN обладает одной необычной особенностью: операция проверки на равенство всегда возвращает отрицательный результат, даже если сравнить его с самим собой. Это означает, что нельзя использовать проверку x == NaN, чтобы определить, является значение переменной x значением NaN. Вместо этого следует выполнять проверку x != x. Эта проверка вернет true тогда и только тогда, когда x имеет значение NaN.
Аналогичную проверку можно выполнить с помощью функции isNaN(). У функции isNaN() есть фатальный недостаток. Она пытается интерпретировать NaN слишком буквально, то есть пытается проверить, является ли переданное значение числом или не числом. Тем не менее это не совсем точно:

```` js
var a = 2 / "foo";
var b = "foo";
a; // NaN
b; "foo"
window.isNaN( a ); // true
window.isNaN( b ); // true
````

* Значение "foo" буквально не является числом, но оно определенно не является значением NaN. Эта ошибка присутствует в JS с самого начала. В ES6 наконец-то появилась замена: Number.isNaN(). Простой
полифил позволит безопасно проверять значения NaN даже в браузерах до ES6:

```` js
if (!Number.isNaN) {
 Number.isNaN = function(n) {
 return (
 typeof n === "number" &&
 window.isNaN( n )
 );
 };
}
var a = 2 / "foo";
var b = "foo";
Number.isNaN( a ); // true
Number.isNaN( b ); // false — теперь правильно!
````

### Infinity

* Согласно спецификации, если операция (например, сложение) дает значение, слишком большое для представления в IEEE 754, результат определяется режимом округления.

* Если говорить упрощенно, Number.MAX_VALUE + Math.pow( 2, 969 ) ближе к Number.MAX_VALUE, чем к Infinity, поэтому он выполняет «округление в меньшую сторону», тогда как Number.MAX_VALUE + Math.pow( 2, 970 ) ближе к Infinity, поэтому выполняется «округление в большую сторону».
После переполнения в направлении одной из бесконечностей возврата уже не будет. Иначе говоря, от конечного можно перейти к бесконечному, но от бесконечного к конечному уже не вернуться.

* С точки зрения и математики, и JavaScript операция Infinity / Infinity не определена. В JS будет получен результат NaN.
Если разделить любое положительное конечное число на Infinity получится 0.
Функция isFinite() возвращает true, если аргумент является числом, отличным от NaN, Infinity или -Infinity.

### -0

* Отрицательный ноль также имеет свои характерные особенности. В операциях сравнения (даже в операции строгой проверки на равенство) он признается равным положительному нулю, что делает эти два значения практически неотличимыми, за исключением случаев, когда они выступают в роли делителей:

```` js
var zero = 0; // Обыч­ный ноль
var negz = -0; // От­ри­ца­тель­ный ноль
zero === negz // => true: ноль и от­ри­ца­тель­ный ноль рав­ны
1/zero === 1/negz // => false: Infinity и -Infinity не рав­ны
При попытке преобразования отрицательного нуля к строковому виду, согласно спецификации, он всегда должен отображаться в виде "0":
var a = 0 / -3; // консоли (некоторых браузеров) поступают правильно
a; // -0 // но спецификация настаивает на том, что нужно врать!
a.toString(); // "0"
a + ""; // "0"
String( a ); // "0"
JSON.stringify( a ); // "0"

Обратные операции (переход от string к number) не лгут:
+"-0"; // -0
Number( "-0" ); // -0
JSON.parse( "-0" ); // -0

Преобразование отрицательного нуля к строковому виду только скрывает истинное значение, операторы сравнения тоже лгут (намеренно):
var a = 0;
var b = 0 / -3;
a == b; // true
-0 == 0; // true
a === b; // true
-0 === 0; // true
0 > -0; // false
a > b; // false

Чтобы отличать -0 от 0 в своем коде:

function isNegZero(n) {
 n = Number( n );
 return (n === 0) && (1 / n === -Infinity);
}
isNegZero( -0 ); // true
isNegZero( 0 / -3 ); // true
isNegZero( 0 ); // false
````

* В некоторых приложениях разработчики используют абсолютную величину значения для представления одного вида информации (например, скорости движения в кадрах анимации), а знак этого числа — для представления другого вида информации (например, направления этого движения).
Например, если в таком приложении переменная дойдет до нуля и утратит свой знак, вы потеряете информацию о том, в каком направлении происходило движение до обнуления. Сохранение знака нуля предотвращает потенциально нежелательную потерю информации.

* В ES6 появился новый метод, который может использоваться для проверки двух значений на абсолютное равенство без каких-либо исключений Object.is():

```` js
var a = 2 / "foo";
var b = -3 * 0;
Object.is( a, NaN ); // true
Object.is( b, -0 ); // true
Object.is( b, 0 ); // false
````

* Object.is() не стоит использовать в тех случаях, когда == или === заведомо безопасны, так как операторы наверняка будут работать намного более эффективно, и безусловно, более идиоматичны и распространены. Метод Object.is(..) в основном предназначен для этих специальных случаев равенства.

### Ошибка округления

* Стандарт представления вещественных чисел IEEE-754, определяет двоичный формат их представления, который может обеспечить точное представление таких дробных значений, как 1/2, 1/8 и 1/1024.
Двоичное представление вещественных чисел неспособно обеспечить точное представление таких простых чисел, как 0.1.
Самый знаменитый побочный эффект использования двоичных чисел с плавающей точкой (который относится ко всем языкам, использующим IEEE 754):

````js
0.1 + 0.2 === 0.3; // false
````

0,1 и 0,2 в двоичном формате с плавающей точкой имеют не точное, а приближенное представление, поэтому при суммировании результат не равен в точности 0,3. Значение получается очень близким (0,30000000000000004), но если условие не выполняется, то «близость» уже несущественна.

Если нужно сравнить два числа (например, 0.1 + 0.2 c 0.3) можно использовать «машинный эпсилон» 2^-52 (2.220446049250313e-16).

В ES6 Number.EPSILON заранее определяется с этим значением допуска. Либо использовать полифил для версий, предшествующих ES6:

```` js
if (!Number.EPSILON) {
 Number.EPSILON = Math.pow(2,-52);
}
````

Number.EPSILON может использоваться для проверки двух чисел на «равенство» (в пределах погрешности округления):

```` js
function numbersCloseEnoughToEqual(n1,n2) {
 return Math.abs( n1 - n2 ) < Number.EPSILON;
}
var a = 0.1 + 0.2;
var b = 0.3;
numbersCloseEnoughToEqual( a, b ); // true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false
````

### MAX / MIN

Максимальное представимое значение с плавающей точкой равно приблизительно 1.798e+308; оно также заранее определено в Number.MAX_VALUE. На другом конце оси Number.MIN_VALUE равно приблизительно 5e-324.

Для чисел существует диапазон «безопасных» значений для «целых» чисел, и он значительно меньше Number.MAX_VALUE. Максимальное целое число, которое может быть «безопасно» представлено (то есть существует гарантия того, что заданное значение действительно имеет однозначное представление), равно 2^53 - 1, что соответствует приблизительно 9007199254740991.

Это значение автоматически заранее определяется в ES6 в форме Number.MAX_SAFE_INTEGER (Number.MIN_SAFE_INTEGER для минимального безопасного числа).

Самая распространенная ситуация, в которой JS-программы сталкиваются c такими большими числами — работа с 64-разрядными идентификаторами из баз данных и т. д. 64-разрядные числа не могут быть точно представлены типом number, поэтому они должны храниться (и передаваться JavaScript и обратно) в  строковом представлении.
# **Теория компиляторов**

**JavaScript** относится к общей категории «динамических» или «интерпретируемых» языков, на самом деле это компилируемый язык. Код не компилируется заранее, как во
многих традиционных компилируемых языках, а результаты компиляции не портируются между разными распределенными системами. Тем не менее **движок** **JavaScript** выполняет многие те же действия, что и любой традиционный **компилятор** (хотя и на более сложном уровне).

В традиционном процессе компиляции блок исходного кода — перед выполнением обычно проходит через три фазы обработки, которые приближенно объединяются термином «компиляция»:

* Лексический анализ/Разбиение на токены (Tokenizing/Lexing) — разбиение последовательности символов на осмысленные (с точки зрения языка) фрагменты, называемые токенами.
Для примера возьмем программу `var a = 2;`. Скорее всего, эта программа будет разбита на следующие токены: `var`, `a`, `=`, `2` и `;`. Пропуски могут сохраняться в виде токенов, а могут и не сохраняться в зависимости от того, имеет это смысл или нет. Разница между `tokenizing` и `lexing` — если при вызове токенизатора активизируются правила разбора с состоянием, определяющие, должен ли данный токен считаться отдельным токеном или частью другого токена, это будет называться `lexing`.

* Разбор (parsing) — преобразование потока (массива) токенов в дерево вложенных элементов, которые в совокупности представляют грамматическую структуру программы. Это дерево называется «абстрактным деревом синтаксиса», или AST
(Abstract Syntax Tree). Дерево для `var a = 2;` может начинаться с узла верхнего уровня `VariableDeclaration`, который содержит дочерний узел `Identifier` (со значением `a`) и другой дочерний узел `AssignmentExpression`, у которого есть
свой дочерний узел с именем `NumericLiteral` (его значение равно `2`).

* Генерирование кода — процесс преобразования AST в исполняемый код. Эта часть сильно зависит от языка, целевой платформы и т. д.

Описанное ранее AST-дерево для `var a = 2;` может быть преобразовано в набор машинных команд для создания переменной с именем `a` (включая резервирование памяти и т. д.) и последующего сохранения значения в `a`.
**Движок** **JavaScript** не ограничивается только этими тремя этапами (как и большинство других **компиляторов**). Например, в процессе разбора и генерирования кода присутствуют фазы оптимизации кода, включая исключение избыточных элементов и т. д.

Для **JavaScript** компиляция во многих случаях выполняется за считаные микросекунды (и менее) до выполнения кода. Для обеспечения максимального быстродействия движка **JS** применяют всевозможные хитрости (например, JIT-компиляцию с отложенной компиляцией и даже оперативной перекомпиляцией и т. д.).
Простоты ради будем считать, что любой фрагмент JavaScript должен компилироваться перед (обычно непосредственно перед) его выполнением. Итак, **компилятор** **JS** берет программу `var a = 2;`, сначала компилирует ее, а потом готовит ее к исполнению (обычно это происходит немедленно).

Рассмотрим процесс как некое подобие разговора между движком, **компилятором** и областью видимости:

* **Движок** — отвечает за всю компиляцию от начала до конца и выполнение программы **JavaScript**.

* **Компилятор** — берет на себя всю черную работу по разбору и генерированию кода.

* **Область видимости** — собирает и ведет список всех объявленных идентификаторов (переменных) и устанавливает строгий набор правил их доступности для кода, выполняемого в данный момент.

Программа `var a = 2;`, с точки зрения **Движка** состоит из разных команд: одну
**Компилятор** обрабатывает во время компиляции, а другую **Движок** обрабатывает во время выполнения. Процесс обработки программы `var a = 2;` **Движком** и другими компонентами:

1. Прежде всего, **Компилятор** проводит лексический анализ и разбирает программу на токены, которые затем разбираются в дерево.
    1. Обнаруживая `var a`, **Компилятор** обращается к **Области видимости**, чтобы узнать, существует ли переменная `a` в наборе этой конкретной **Области видимости**. Если переменная существует, то **Компилятор** игнорирует объявление и двигается дальше. В противном случае **Компилятор** обращается к **Области видимости** для объявления новой переменной с именем `a` в наборе
    этой **области видимости**.
    2. **Компилятор** генерирует код для последующего выполнения **Движком** для обработки присваивания `a = 2`. Код, выполняемый **Движком**, сначала спрашивает у **Области видимости**, доступна ли переменная с именем `a` в наборе текущей области видимости. Если переменная доступна, то **Движок** использует эту переменную. Если нет, **Движок** ищет в другом месте. Если **Движок** в конечном итоге находит переменную, он присваивает ей значение `2`. Если нет, **Движок** поднимает тревогу и сообщает об ошибке.

Когда **Движок** выполняет код, сгенерированный **Компилятором** на шаге `2`, он должен провести поиск переменной `a` и определить, была ли она объявлена; этот поиск называется проверкой Области видимости. Однако тип проверки, выполняемой **Движком**, влияет на результат поиска.

В примере **Движок** будет выполнять LHS-поиск переменной `a`. Другая разновидность поиска называется RHS. Сокращения означают «LeftHand Side» (левосторонний) и «RightHand Side» (правосторонний) к операции присваивания.

Иначе говоря, LHS-поиск выполняется при нахождении переменной в левой части операции присваивания, а RHS-поиск выполняется при нахождении переменной вправой части операции присваивания. Для наших целей RHS-поиск неотличим от простого поиска значения некоторой переменной, тогда как LHS-поиск пытается найти саму переменную-
контейнер для присваивания. В этом отношении термин RHS на самом деле означает не «правую сторону присваивания» как таковую, а скорее «не левую сторону». В несколько упрощенном виде можно считать, что RHS означает «получить исходное значение».

***

* `console.log( a );` ссылка на `a` является RHS-ссылкой, потому что `a` здесь ничего не присваивается. Вместо этого мы собираемся прочитать значение `a`, чтобы значение могло быть передано `console.log()`.

* `a = 2;` ссылка является LHS-ссылкой.

«Левая/правая сторона присваивания» в обозначениях LHS и RHS не обязательно буквально означает «левая/правая сторона оператора присваивания =». Присваивание также может выполняться другими способами, поэтому лучше концептуально рассматривать их как «приемник присваивания» (LHS) и «источник присваивания» (RHS).
Возьмем следующую программу, в которой задействованы как LHS-, так и RHS-ссылки:

```` js
function foo(a) {
 console.log( a ); // 2
}
foo( 2 );
````

Последняя строка с вызовом функции `foo(..)` также требует RHS-ссылки на `foo`, которая означает «Найти значение foo и предоставить его мне». Более того, `(..)` означает, что значение `foo` должно быть выполнено, а значит, это должна быть функция. Здесь тоже выполняется неочевидное, но важное присваивание.
Возможно, вы упустили неявное присваивание `a = 2` в этом фрагменте кода. Оно происходит при передаче значения `2` в аргументе функции `foo(..)`, при котором значение `2` присваивается параметру `a`. Чтобы (неявно) присвоить значение параметру `a`, выполняется LHS-поиск.
Также здесь присутствует RHS-ссылка на значение `a`; полученное значение передается `console.log(..)`. Для выполнения `console.log(..)` тоже необходима ссылка. Сначала выполняется RHS-поиск объекта console, после чего поиск по свойствам определяет, существует ли среди них метод с именем log.
Наконец, можно на концептуальном уровне представить, что при передаче значения `2` (посредством RHS-поиска переменной `a`) методу `log(..)` происходит LHS/RHS-взаимодействие. Внутри встроенной реализации `log(..)` можно считать, что у нее есть параметры, с первым из которых (вероятно, с именем arg1) выполняется LHS-поиск, перед тем как ему будет присвоено значение `2`. Возникает соблазн представить объявление функции `function foo(a) {…` как обычное объявление переменной с присваиванием, что-то вроде `var foo` и `foo = function(a){…`. При
таком представлении возникает столь же соблазнительная мысль считать, что при таком объявлении функции также задействуется LHS-поиск. Однако здесь существует неочевидное, но важное различие: **Компилятор** обрабатывает объявление и определение значения во время генерирования кода, чтобы во время выполнения кода **Движком** «присваивание» значения функции `foo` не требовало никакой дополнительной обработки. А следовательно, на самом деле неправильно рассматривать объявление функции как присваивание с LHS-поиском в том смысле, в котором он здесь рассматривается.

***

Общение **Движка** с **Областью видимости**

````js
function foo(a) {
 console.log( a ); // 2
}
foo( 2 );
````

Представим это взаимодействие (с обработкой этого фрагмента) в виде разговора:

* **Движок**: Эй, **Область видимости**, у меня есть RHS-ссылка на `foo`. Знаешь, что это?

* **Область видимости**: Ну да, знаю. **Компилятор** объявил `foo` секунду назад. Это функция. Вот, держи.

* **Движок**: Перехожу к выполнению `foo`.

* **Движок**: Эй, **Область видимости**, у меня есть LHS-ссылка на `а`. Знаешь, что это?

* **Область видимости**: Ну да, знаю. **Компилятор** только что объявил `a` как формальный параметр `foo`. Вот, держи.

* **Движок**: Теперь пора присвоить `a` значение `2`.

* **Движок**: Мне нужно выполнить RHS-поиск для `console`. Знаешь, что это?

* **Область видимости**: Да, я знаю, что такое `console` — это встроенный объект. Вот, держи.

* **Движок**: Теперь ищу `log(..)`. Отлично, это функция.

* **Движок**: **Область видимости**, а сможешь помочь с RHS-ссылкой на `a`? Вроде бы я помню что-то такое, но хочу проверить лишний раз.

* **Область видимости**: Та же переменная, ничего не изменилось. Вот, держи.

* **Движок**: Передаю значение `a`, то есть `2`, функции `log(..)`.

***

## **Вложенная область видимости**

Подобно тому как блок или функция может вкладываться внутрь другого блока или функции, области видимости могут вкладываться в другие области видимости. Если переменную не удается найти в текущей области видимости, **движок** обращается к следующей внешней области видимости. Это продолжается до тех пор, пока не будет найдена искомая переменная или не будет достигнута внешняя (то есть глобальная) область видимости.

```` js
function foo(a) {
 console.log( a + b );
}
var b = 2;
foo( 2 ); // 4
````

RHS-ссылку для `b` не удается разрешить внутри функции `foo`, но она может быть разрешена во внешней области видимости (в данном случае глобальной).

Возвращаясь к разговору между **Движком** и **Областью видимости**, мы услышим следующее:

* **Движок**: Эй, **Область видимости**, знаешь, что такое `b`? У меня тут RHS-ссылка.

* **Область видимости**: Нет, впервые слышу про такое.

* **Движок**: Эй, **Область видимости** за пределами `foo…` Э, да ты глобальная
**Область видимости**? Ну и ладно. Знаешь, что такое `b`? У меня тут RHS-ссылка.

* **Область видимости**: Ага, знаю. Вот, держи.

***

Простые правила проверки вложенных областей видимости: Движок начинает с текущей области видимости и ищет переменную в ней. Если поиск не дает результатов, **Движок** поднимается на один уровень вверх и т. д. При достижении внешней глобальной области видимости поиск прекращается независимо от того, была найдена переменная или нет.

***

Почему важно отличать LHS от RHS?
Потому что эти два типа поиска по-разному ведут себя в ситуации, когда переменная еще не была объявлена (не найдена ни в одной из просмотренных областей видимости).

```` js
function foo(a) {
 console.log( a + b );
 b = a;
}
foo( 2 );
````

Когда RHS-поиск для `b` происходит впервые, он завершается неудачей. Переменная, не найденная в области видимости, считается «необъявленной». Если RHS-поиск не находит переменную ни в одной из вложенных областей видимости, **движок** выдает ошибку `ReferenceError`. С другой стороны, если **движок** выполняет LHS-поиск и прибывает на верхний этаж (глобальная **область видимости**), так и не обнаружив искомое, если программа не выполняется в строгом режиме, в глобальной области видимости создается новая переменная с указанным именем, которая передается движку.
Режим `strict`, добавленный в ES5, во многих отношениях отличается от обычного/нестрогого режима. Одно из отличий заключается в том, что он запрещает автоматическое/неявное создание глобальных переменных. В этом случае LHS-поиск не вернет переменную с глобальной областью видимости, и **движок** выдаст ошибку `ReferenceError` по аналогии со случаем RHS. Если переменная будет найдена для RHS-поиска, но вы пытаетесь сделать с ее значением нечто невозможное (например, попытка выполнить как функцию значение, которое функцией не является, или обращение к свойству для значения `null` или `undefined`), **движок** выдаст другую разновидность ошибки — `TypeError`. Ошибка `ReferenceError` относится к проблемам при разрешении области видимости, а ошибка `TypeError` подразумевает, что разрешение области видимости прошло успешно, но была сделана попытка выполнить с результатом недопустимую/невозможную операцию.

## **Итоги:**

* **Область видимости** — набор правил, определяющих, где и как осуществляется поиск переменной (идентификатора). Поиск может выполняться для цели присваивания переменной (LHS, или левосторонняя ссылка) или же для цели чтения ее значения
(RHS, или правосторонняя ссылка). LHS-ссылки появляются в результате операций присваивания. Присваивания, связанные с областью видимости, могут происходить либо в операторе `=`, либо при передаче аргументов параметрам функции.

* **Движок** JavaScript сначала компилирует код перед выполнением. При этом команды вида `var a = 2;` разбиваются на две части:

1. Сначала `var a` для объявления переменной в области видимости. Этот шаг выполняется перед выполнением кода.

2. Потом `a = 2` для поиска переменной (LHS-ссылка) и присваивания ей, если переменная будет успешно найдена.

* Поиск по LHS- и RHS-ссылкам начинается с текущей области видимости. При необходимости (то есть если искомый идентификатор не будет найден) поиск поднимается вверх от вложенной области видимости, по одной области видимости за раз, пока не доберется до глобальной области видимости. Здесь поиск станавливается: либо идентификатор найден, либо нет.

* Для неразрешенных RHS-ссылок выдается исключение `ReferenceError`.

* Для еразрешенных LHS-ссылок автоматически создается глобальная переменная с заданным именем (если не действует режим `strict`), или происходит ошибка `ReferenceError` (в режиме `strict`).

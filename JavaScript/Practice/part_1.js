// Задачи из источника https://habr.com/ru/post/351874/

// Есть некоторая строка (var str = 'fgfggg';), что будет, если мы возьмем str[0]?

var str = 'fgfggg';

/** В стандарте ECMAScript 5 строки могут интерпретироваться как массивы, доступные только для чтения. К отдельным символам строки можно обращаться с помощью индексов в квадратных скобках: */

console.log(str[0]); // f

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Реализовать методы, которые в процессе выполнения строки (2).plus(3).minus(1) дали бы на выходе 4.

/** Поскольку, мы работаем с числами, надо расширить прототип Number новыми методами. */

Number.prototype.plus = function (value) {
	return this + value;
};

Number.prototype.minus = function (value) {
	return this - value;
};

/** Число 2 будет доступно через this в функции plus. Из нее мы возвращаем результат сложения числа, на которое указывает this и числа, переданного в качестве аргумента. Аналогично для minus. */

console.log((2).plus(3).minus(1)); // 4

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Дана функция, она принимает в качестве аргументов строки '*', '1', 'b', '1c', реализуйте ее так, что бы она вернула строку '1*b*1c'

function getStr() {
	return [].slice.call(arguments, 1).join(arguments[0])
};

/** берём пустой массив, вызываем у него метод slice, у slice вызываем метод call. Первым аргументом в call передаем подобный массиву объект arguments, содержащий агрументы, переданные в функцию. Arguments будет использоваться в качестве this метода slice. Вторым аргументом передаём начальный индекс для метода slice (1). Так как конечный индекс для slice не передаём, то slice вернёт массив начиная с первого элемента до конца массивва. Далее вызываем метод join и аргументом (сепаратором) передаём нулевой элемент arguments(*)  */

console.log(getStr( '*', '1', 'b', '1c'));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Есть массив в котором лежат объекты с датами, отсортировать по датам.

const arr = [{date: '10.01.2017'}, {date: '05.11.2016'}, {date: '21.13.2002'}];

const getSortedDate = dateArray => {

    const sortedDateArr = [...dateArray].sort((prev, next) => {
        /** переводим строковое представление в численное. Метод Date.parse принимает строку в формате (один из форматов) "год-месяц-день"  и возвращает
         * timestamp в мс. Если в датах нет ошибки (например здесь 13 месяц в третьей дате), то сортировка сработает корректно. Если в условии задачи есть неккоректные даты нужно использовать другой метод (перевести даты в массивы, каждый элемен преобразовать в число и воспользоваться конструктором new Date. new Date может обработать неккоректные даты)
        */
        const prevInNumber = Date.parse(prev.date.split('.').reverse().join('-'));
        const nextInNumber = Date.parse(next.date.split('.').reverse().join('-'));
        return prevInNumber - nextInNumber;
    });

    return sortedDateArr;
};

console.log(getSortedDate(arr));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Есть несколько слов, определить состоят ли они из одних и тех же букв('кот', 'ток', 'окт');

const words = ['kot', 'tok', 'okt'];
const words1 = ['kot', 'tok', 'ott'];

const checkWords = arr => {
    /** сортируем исходный массив по алфавиту(неважно в какой последовательности) */
    const sortedArrItems = arr.map(item => item.split('').sort().join(''));

    /** создаем коллекцию Set - если есть дублирующиеся элементы, они не будут включены в Set */
    const uniqArr = new Set(sortedArrItems);

    /** проверяем размер коллекции - если он равен еденице, значт все слова в исходном массиве состоят из одинаковых символов */
    return uniqArr.size === 1;
}

console.log(checkWords(words));
console.log(checkWords(words1));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Объяснить в какой последовательности выведутся цифры и почему так.

/** Так как хоть js и асинхронен, но внутри него есть очередь выполнения и setTimeout и setInterval, если им указан 0, помещают вызов функции в конец очереди. */

console.log(1);

setTimeout(function() {
	console.log(2);
}, 0)

console.log(3); // 1, 3, 2

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Что будет выведено в консоль, как можно модифицировать пример что бы он возвращал правильный результат (назовите как можно больше способов)?

/** проблема в области видимости счётчика цикла объявленного с помощью ключевого слова var. При каждой итерации цикла счётчик добежит до конечного значения, потом выведется в консоль */

// for (var i = 0; i < 10; i++) {
// 	setTimeout(function () {
// 		console.log(i);
// 	}, 100);
// } //10 раз 10

// /** самый простой вариант поменять var на let, у let блочная область видимости */

// for (let i = 0; i < 10; i++) {
// 	setTimeout(function () {
// 		console.log(i);
// 	}, 100);
// }

// /** второй варант решение через замыкание - внутри цикла объявляем IIDE туда помещаем выполняесый код и в качестве аргрумента передаём счётчик. На каждой итерации цикла значение счётчика будет замыкаться внутри IIFE и выводится в консоль */

// for (var i = 0; i < 10; i++) {
//     (function (j) {
//         setTimeout(function () {
//             console.log(j);
//         }, 100);
//     })(i)
// };

// /** вариант с использованием bind() - bind создаёт новую функцию с привязкой контекста выполнения, в качестве аргумента в созданную функцию передаётся счётчик */

// for (var i = 0; i < 10; i++) {
// 	setTimeout(function (i) {
// 		console.log(i);
// 	}.bind(this, i), 100);
// };

// /** методам setInterval и setTimeout можно передать аргументы, которые будут прокинуты в качестве аргументов калбек-функции */

// for (var i = 0; i < 10; i++) {
// 	setTimeout(function (i) {
// 		console.log(i);
// 	}, 100, i);
// };


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Числа от 1 до 100 лежат в массиве, они хаотично перемешанные, от туда изъяли одно число, надо найти, что это за число. алгоритм не должен превышать O(n^2) сложности.

/** Создадим массив с помощью генератора */

const fillArray = n => {
    function* g() {
      let i = 1;

      while (i <= n) {
        yield i++
      }
    }

    return Array.from(g());
};

const filledArr = fillArray(100);
/** находим сумму созданного массива */
const filledArrSum = [...filledArr].reduce((acc, curr) => acc + curr, 0);

/** удаляем один любой элемент из массива */
filledArr.splice(35, 1);

const findNumber = arr => {
    // находим сумму элементов массива без удаленного элемента
    const summ = arr.reduce((sum, curr) => sum + curr, 0);
    // возвращаем разницу между суммой начального массива и массива с удаленным элементом
    return filledArrSum - summ;
};

console.log(findNumber(filledArr));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Реализовать функцию f: f(2, 3) -> 5, при вызове f(2)(3), тоже вернет 5
const curry = (a, b) => {
if (b !== undefined) {
    return a + b;
}

return function (b) {
            return a + b;
    }
}

console.log(curry(2, 3));
console.log(curry(2)(3));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Напишите код, который сделает из массива объект на входе массив

const arr1 = [
    {name: 'width', value: 10},
    {name: 'height', value: 20}
];

const getObj = arr => {
    const result = {};

    arr.forEach(element => {
        result[element.name] = element.value;
    });

    return result;
};

console.log(getObj(arr1));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Задача: Уникализация значений в массиве. Необходимо написать функцию, принимающую в аргументах массив целых чисел и возвращающую новый массив, состоящий только из уникальных значений первого массива.
*/

const arr2 = [1, 1, 2, 2, 4, 2, 3, 7, 3];

/** решение с использованием коллекции уникальных значений */
const getUniq = arr => Array.from(new Set(arr));

/** с использованием фильтра */
const getUniq1 = arr => arr.filter((item, index, array) => array.indexOf(item) === index)

/** с проходом циклом */
const getUniq2 = arr => {
    const uniqs = [];

    // for (let i = 0; i < arr.length; i++) {
    //     if (!~uniqs.indexOf(arr[i])) { // -(x + 1)
    //         uniqs.push(arr[i]);
    //     }
    // }

    arr.forEach(item => !uniqs.includes(item) && uniqs.push(item));

    return uniqs;
};

console.log(getUniq2(arr2));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Необходимо написать функцию, принимающую в аргументах многомерный массив неограниченной вложенности и возвращающую новый одномерный массив, состоящий из элементов со всех уровней вложенности исходного массива. */

const arr3 = [1, [2, [3, [4,5]]]];

/** метод массива flat разворачивает массивб передать как аргумент уровень вложенности */
console.log(arr3.flat(Infinity));

/** рекурсия */
const flat = arr => {
    let flatArr = [];
    arr.forEach(item => {
        if (Array.isArray(item)) {
            flatArr = [...flatArr, ...flat(item)]
        } else {
            flatArr.push(item)
        }
    })
    return flatArr;
}

/** рекурсия через стек */
const flat1 = arr => {
    const stack = [...arr];
    const result = [];

    while(stack.length) {
        const next = stack.pop();

        if (Array.isArray(next)) {
            stack.push(...next);
        } else {
            result.push(next)
        }
    }
    return result.reverse();
};

console.log(flat1(arr3));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Написать функцию, принимающую аргументом массив чисел и возвращающую новый массив, состоящий из удвоенных значений первого.

const arr4 = [1, 2, null, 7, 8, null, 3];

// фильтруем и умножаем
const getDouble = arr => arr.filter(Boolean).map(item => item * 2);

console.log(getDouble(arr4));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Необходимо написать функцию, принимающую в аргументах массив и возвращающую новый массив, в котором отсортированы все нечетные числа по возрастанию, в то время как чётные остаются на своих местах. */

const arr5 = [7, 3, 4, 9, 5, 2, 17]; // => [3, 5, 4, 7, 9, 2, 17]

const oddSort = arr => {
    arr.forEach((item, index) => {
        if (item % 2 !== 0) {
            let sortNumber = item;

            for (let i = 0; i < index; i++) {
                if (arr[i] % 2 !== 0) {
                    if (arr[i] > sortNumber) {
                        const tmp = sortNumber;
                        sortNumber = arr[i];
                        arr[i] = tmp;
                    }
                }
            }
            arr[index] = sortNumber;
        }
    })
    return arr;
}

console.log(oddSort(arr5));

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Необходимо реализовать функцию, принимающую в аргументах строку, состоящую из букв и вернуть новую строку, в которой повторяющиеся буквы заменены количеством повторений.

// const string1 = 'AVVVBBBVVXDHJFFFFDDDDDDHAAAAJJJDDSLSSSDDDD'; // => 'AV3B3V2XDHJF4D6HA4J3D2SLS3D4'

// const parser = str => {
//     const result = [];
//     const arrFromStr = str.split('');

//     for (i = 0; i < arrFromStr.length; i++) {
//         let count = 0;

//         for (j = i + 1; j < arrFromStr.length; j++) {
//             if (arrFromStr[i] !== arrFromStr[j]) {
//                 result.push(arrFromStr[i]);
//                 break;
//             } else {
//                 count += 1;
//                 // result.push(arrFromStr[i]);
//                 result.push(count);
//             }
//         }
//     }
//     return result.join('');
// };

// console.log(parser(string1));
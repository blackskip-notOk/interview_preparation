# **Принципы ООП**

## **Ссылки**

* [**Объектно-ориентированная парадигма**](#объектно-ориентированная-парадигма)
* [**Абстракция**](#абстракция)
* [**Инкапсуляция**](#инкапсуляция)
* [**Полиморфизм**](#полиморфизм)
* [**Наследование**](#наследование)
* [**Классовое наследование**](#классовое-наследование-в-javascript)
* [**Прототипное наследование**](#прототипное-наследование)
* [**Классы vs Прототипы**](#классы-vs-прототипы)
* [**Композиция**](#композиция)

***

## **Объектно-ориентированная парадигма**

**Объектно-ориентированное программирование** — это шаблон проектирования программного обеспечения, который позволяет решать задачи с точки зрения объектов и их взаимодействий. ООП обычно реализуется с помощью классов или прототипов. Большинство объектно-ориентированных языков (Java, C++, Ruby, Python и др.) используют наследование на основе классов. JavaScript реализует ООП через прототипное наследование.

Таким образом, система представляется в виде набора объектов предметной области, которые взаимодействуют между собой некоторым образом. Каждый объект обладает тремя cоставляющими:

* идентичность (identity) - то, что отличает один объект класса от другого объекта класса,
* состояние (state) - набор всех его полей и их значений,
* поведение (behaviour) - набор всех методов класса объекта.

***

## **Абстракция**

Все языки программирования предоставляют их пользователю определённые абстракции. Так, языки семейства ассемблер являются в своём роде абстракцией соответствующих микропроцессоров, поскольку позволяют отвлечься от деталей их реализации и общаться с ними через определённый набор более высокоуровневых инструкций. Императивные языки программирования, последовавшие за ассемблером, например Basic, Fortran, C, являются более высоким уровнем абстракции над ассемблерными языками – они дают возможность использовать более привычные человеку синтаксические конструкции за счёт приближения синтаксиса к естественным языкам.

Объектно-ориентированные языки, такие как Java, выводят разработку на ещё более высокий уровень абстракции: объекты в ООП по своей сути представляют собой модели понятий окружающего мира, таких как Работник, Сервер, Запись в дневнике, и выделяют только те свойства этого понятия, которые необходимы в конкретном случае для решения конкретной проблемы.

В этом и состоит абстракция: фокусировка разработчика на конкретных свойствах объекта зависит от тех задач, которые призван решать объект. Следствием такого подхода является то, что, если в императивных языках разработчику необходимо думать в терминах компьютерной логики, в объектно-ориентированных языках разработчик думает в терминах проблемной области, в которой он разрабатывает приложения.
***

## **Инкапсуляция**

это принцип, согласно которому любой класс и в более широком смысле – любая часть системы должны рассматриваться как «черный ящик»: пользователь класса или подсистемы должен видеть только интерфейс (т.е. список декларируемых свойств и методов) и не вникать во внутреннюю реализацию.

Правильная инкапсуляция важна по многим причинам:

1. Она способствует переиспользованию компонентов: поскольку в этом случае компоненты взаимодействуют друг с другом только посредством их API и безразличны к изменениям внутренней структуры, они могут использоваться в более широком контексте.

2. Инкапсуляция ускоряет процесс разработки: слабо связанные друг с другом компоненты (то есть компоненты, чей код как можно меньше обращается или использует код других компонентов) могут разрабатываться, тестироваться и дополняться независимо.

3. Правильно инкапсулированные компоненты более легки для понимания и процесса отладки, что упрощает поддержку приложения.

***

## **Полиморфизм**

это возможность использовать классы – потомки в контексте, который был предназначен для класса – предка.
Этот принцип неразрывно связан с другим принципом ООП – наследованием, которое помогает реализовать полиморфизм. Возьмем для примера абстрактный класс «Автомобиль», который наследуют два конкретных класса – «Спортивный автомобиль» и «Грузовой автомобиль».
И спортивные, и грузовые автомобили будут обладать общими характеристиками и будут иметь возможность выполнять общие для всех автомобилей действия, которые указаны в абстрактном классе-родителе, но конкретная реализация этих действий может быть разной.
Например, общее для всех автомобилей действие «завестись» у спортивного автомобиля может быть реализовано путем нажатия кнопки, а у грузового - с помощью ключа. Один результат – разные решения. В этом и состоит полиморфизм.
Более строго, полиморфизм - один из принципов ООП, позволяющий вызовом переопределённого метода через переменную класса-родителя получить поведение, которое будет соответствовать реальному классу-потомку, на который ссылается эта переменная. За этим определением кроется возможность языка программирования для декомпозиции задачи и рефакторинга if'ов и switch'ей.
***

## **Наследование**

это возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (суперкласса), добавляя при необходимости новые свойства и методы.

Наследование является одним из важнейших принципов объектно-ориентированного программирования, поскольку оно позволяет создавать иерархические структуры объектов. Используя наследование, можно создать общий класс, который будет определять характеристики и поведение, свойственные какому-то набору связанных объектов. В дальнейшем этот класс может быть унаследован другими, более частными классами, каждый из которых будет добавлять уникальные, свойственные только ему характеристики и дополнять или изменять поведение базового класса. В терминах Java такой общий класс называется суперклассом (superclass), или базовым классом (base class), или классом-родителем (parent class), а класс, его наследующий, - подклассом (subclass), или дочерним классом (child class), или классом-потомком (derived class). Когда-то считалось, что «У идеального программиста дерево наследования уходит в бесконечность и заканчивается абсолютно пустым объектом», потому как когда-то люди не очень хорошо понимали то, что наследование — это способ выразить такое свойство реального мира как иерархичность, а не способ переиспользовать код, отнаследовав машину от холодильника, потому что у обоих предметов есть ручка. Наследования желательно по возможности избегать, потому что наследование является очень сильной связью. Для уменьшения количества уровней наследования рекомендуется строить дерево «снизу-вверх».

Джо Армстронг (создатель Erlang) высказал мысль об этом лучшим образом:

* "Проблема объектно-ориентированных языков заключается во всей их неявной среде, которую они всегда тянут за собой. Вы хотели банан, а получили гориллу, держащую банан, вместе со всеми джунглями."

***

### **Классовое наследование в JavaScript**

````js
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
  }
  getFullName() {
    return this.firstName + ' ' + this.lastName
  }
}
````

При помощи ключевого слова `class` из ES6 создаётся класс `Person` со свойствами `firstName` и `lastName`, которые хранятся в `this`. Значения свойств задаются в конструкторе, а доступ к ним осуществляется в методе `getFullName()`.

Создаётся экземпляр класса `Person` с именем `person` с помощью ключевого слова `new`:

````js
let person = new Person('Dan', 'Abramov')
person.getFullName() //> "Dan Abramov"
// Мы можем использовать акцессор или получить доступ напрямую
person.firstName //> "Dan"
person.lastName //> "Abramov"
````

Объекты, созданные с помощью ключевого слова `new`, изменяемы. Другими словами, изменения в классе повлияют на все объекты, являющиеся экземплярами этого класса, а также на дочерние классы, которые его расширяют (`extends`).

Для расширения класса можно создать другой класс. Расширяем класс `Person` с помощью класса `User`. `User` — это `Person` с почтой и паролем:

````js
class User extends Person {
  constructor(firstName, lastName, email, password) {
    super(firstName, lastName)
    this.email = email
    this.password = password
   }
   getEmail() {
     return this.email
   }
   getPassword() {
     return this.password
   }
}
````

Выше мы создали класс `User`, расширяющий возможности `Person` путём добавления свойств `email` и `password` и функций доступа к ним. В функции `App()` ниже мы создаётся объект нового класса `user`:

````js
function App() {
  let user = new User('Dan',
                      'Abramov',
                      'dan@abramov.com',
                      'iLuvES6')
  user.getFullName() //> "Dan Abramov"
  user.getEmail() //> "dan@abramov.com"
  user.getPassword() //> "iLuvES6"
  user.firstName //> "Dan"
  user.lastName //> "Abramov"
  user.email //> "dan@abramov.com"
  user.password //> "iLuvES6"
}
````

Всё вроде бы хорошо работает, но использование классового подхода к наследованию привело к большому конструктивному недостатку: откуда пользователи класса `User` (например, `App`) могут знать, что у этого класса есть свойства `firstName` и `lastName` и функция `getFullName`? Одного взгляда на код класса `User` недостаточно для того, чтобы сказать что-либо о его родительском классе. В итоге приходится копаться в документации или искать нужный код по всей иерархии классов.

Как говорит Дэн Абрамов:

* "Проблема с наследованием заключается в том, что у потомков слишком высокий уровень доступа к деталям реализации каждого базового класса в иерархии и наоборот. После изменения требований рефакторинг иерархии классов настолько сложно провести, что она превращается в полную неразбериху со следами устаревших требований."

Классовое наследование построено на создании связей через зависимости. На основе базовых классов (или суперклассов) создаются производные классы. Классовое наследование хорошо подходит для небольших и простых приложений, которые редко меняются и у которых не более одного уровня наследования (неглубокие деревья наследования позволяют избежать проблемы хрупкого базового класса) или совершенно разные сценарии использования. Однако по мере расширения иерархии такое наследование со временем будет невозможно поддерживать.

Эрик Эллиот описал, как классовое наследование может потенциально привести к провалу проекта, а в худшем случае — к провалу компании:

* "Как только у вас наберётся достаточно клиентов, использующих `new`, вы даже при желании не сможете изменить реализацию конструктора, а если попытаетесь, то сломаете весь чужой код."

Когда много производных классов с очень разными функциями наследуются от одного базового класса, любое, казалось бы, безобидное изменение в базовом классе может привести к сбою в работе производных. За счёт усложнения кода и всего процесса создания продукта вы могли бы смягчить побочные эффекты, создав контейнер для инъекций зависимостей. Это обеспечило бы единый интерфейс для создания сервисов, потому что позволило бы абстрагироваться от подробностей создания.
***

### **Прототипное наследование**

В прототипном наследовании классы не используются совсем. Вместо этого объекты создаются из других объектов. Мы начинаем с обобщённого объекта — прототипа. Прототип можно использовать для создания других объектов путём его клонирования или расширять его разными функциями.

**JavaScript** — прототипно-ориентированный язык.

````js
typeof Person //> "function"
typeof User //> "function"
````

Классы в ES6 — на самом деле синтаксический сахар для существующего в **JavaScript** прототипного наследования. Под капотом при создании класса с помощью ключевого слова `new` создаётся новый объект функции с кодом из `constructor`.

Из книги Дугласа Крокфорда «JavaScript: сильные стороны»:

Посмотрим на один из таких объектов, доступных в **JavaScript** «из коробки», — **Array**.
Массивы наследуются от `Array.prototype`, который включает в себя много методов, разделённых на акцессоры (не изменяют исходный массив), мутаторы (изменяют исходный массив) и итераторы (применяют функцию, переданную в качестве аргумента, на каждом элементе массива для создания нового).

Предположим, что мы хотим расширить прототип `Array` новым методом `partition()`, который делит массив на два новых в зависимости от предиката. Вот как это можно реализовать:

````js
Array.prototype.partition = function(pred) {
  let passed = [];
  let failed = [];

  for(let i = 0; i < this.length; i++) {
    if (pred(this[i])) {
      passed.push(this[i])
    } else {
     failed.push(this[i])
   }
  }
  return [ passed, failed ];
}
````

Теперь мы можем применить `partition()` на любом массиве:

````js
[1,2,3,4,5].partition(e => e <=3);
//> [[1, 2, 3], [4, 5]]
````

Создадим `Person` и `User` с помощью прототипного наследования:

````js
function Person(firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

Person.prototype.getFullName = function () {
  return this.firstName + ' ' + this.lastName
}
````

Теперь мы можем использовать прототип `Person` таким образом:

````js
let person = new Person('Dan', 'Abramov')
person.getFullName() //> Dan Abramov
````

`person` — объект. Если ввести `console.log(person)`, мы увидим следующее:

````js
Person {
  firstName: "Dan",
  lastName: "Abramov",
  __proto__: {
    getFullName: f
    constructor: f Person(firstName, lastName)
  },
  __proto__: Object
}
````

Для `User` нам всего лишь нужно расширить класс `Person`:

````js
function User(firstName, lastName, email, password) {
  // call super constructor:
  Person.call(this, firstName, lastName)
  this.email = email
  this.password = password
};

User.prototype = Object.create(Person.prototype);

User.prototype.setEmail = function(email) {
  this.email = email
};

User.prototype.getEmail = function() {
  return this.email
};

user.setEmail('dan@abramov.com');
````

`user` — объект. Если ввести `console.log(user)`, мы увидим следующее:

````js
User {
  firstName: "Dan",
  lastName: "Abramov",
  email: "dan@abramov.com",
  password: "iLuvES6",
  __proto__: Person {
    getEmail: f ()
    setEmail: f (email)
    __proto__: {
      getFullName: f,
      constructor: f Person(firstName, lastName)
      __proto__: Object
    }
  }
}
````

Что будет, если мы захотим изменить функцию `getFullName()` для `User`? Как этот код повлияет на `person` и `user`?

````js
User.prototype.getFullName = function () {
  return 'User Name: ' +
         this.firstName + ' ' +
         this.lastName
};

user.getFullName() //> "User Name: Dan Abramov"
person.getFullName() //> "Dan Abramov"
````

Как и ожидалось, на `person` это никак не отразилось.

Давайте добавим в `Person` атрибут `gender` и соответствующие геттер и сеттер:

````js
Person.prototype.setGender = function (gender) {
  this.gender = gender
};

Person.prototype.getGender = function () {
  return this.gender
};

person.setGender('male')
person.getGender() //> male
user.getGender() //> возвращает undefined, хотя это функция
user.setGender('male')
user.getGender() //> male
````

Изменения затронули как `person`, так и `user`, поскольку `User` наследуется от `Person`, поэтому при изменении последнего меняется и `User`.
***

### **Классы vs Прототипы**

Дэн Абрамов говорит, что:

* "Классы скрывают прототипное наследование в основе **JS**. Классы побуждают к использованию наследования, но лучше использовать композицию.
Классы, как правило, не дают вам изменить первую плохую структуру проекта, которая пришла вам в голову.
Вместо классовой иерархии лучше создайте несколько фабричных функций. Они могут вызывать друг друга по цепочке, настраивая своё поведение. Также вы можете научить «основную» фабричную функцию принимать «стратегию», настраивающую поведение других фабричных функций, и передавать её из остальных фабричных функций."

Прототипное наследование (prototypal inheritance) имеет лучшую эффективность памяти, чем классическое наследование, благодаря тому, что оно разделяет ссылки памяти своих свойств прототипа с теми объектами, которые наследуют от него. В классическом наследовании, экземпляры класса создают новые ссылки на память для каждого унаследованного свойства.

**Программирование на основе прототипов** - это стиль объектно-ориентированного программирования, в котором наследование выполняется через процесс повторного использования существующих объектов посредством делегирования, которые служат как prototypes. Сторонники программирования на основе прототипов утверждают, что данный стиль поощряет программиста сосредоточиться на поведении некоторого набора примеров и лишь позднее, беспокоиться о классификации этих объектов в архетипические объекты, которые впоследствии используются аналогично классам.

**Программирование на основе классов**, или же, ориентация на классы, - это стиль объектно-ориентированного программирования (ООП), в котором наследование происходит через определение классов объектов, вместо наследования, которое происходит только через объекты.

* **Tight Coupling** (сильная связанность) относится к волновым эффектам, которые могут произойти с подклассами (дочерние классы), когда вносится изменение в суперкласс (родительский класс). Tight Coupling может привести ко многим непреднамеренным эффектам для подклассов. Tight Coupling может помочь избежать повторений в коде.
* **Хрупкая проблема базового класса** является фундаментальной архитектурной проблемой систем объектно-ориентированного программирования, в которых базовые классы (суперклассы) считаются «хрупкими», потому что, казалось бы, безопасные модификации базового класса, когда они наследуются производным классом, могут привести к сбоям в работе производных классов.
* **Проблема гориллы с бананом** относится к проблеме наследования слишком много от суперкласса. «Будто тебе нужен банан, а ты получаешь банан в придачу с гориллой в джунглях»

Классическое наследование требует превосходного предвидения, чтобы избежать проблем неправильного наследования.
***

### **Композиция**

**JavaScript** позволяет легко объединить связанные функции и данные в объекте:

````js
const Person = {
  firstName: 'firstName',
  lastName: 'lastName',
  getFullName: function() {
    return `${this.firstName} ${this.lastName}`
  }
}
````

Теперь мы можем использовать объект `Person` таким образом:

````js
let person = Object.create(Person);

person.getFullName() //> "firstName lastName"

// Присваиваем значения переменным внутреннего состояния
person.firstName = 'Dan'
person.lastName = 'Abramov'

// Получаем к ним доступ
person.getFullName() //> "Dan Abramov"
````

Создадим объект `User`, склонировав объект `Person`, и добавим туда дополнительные данные и функции:

````js
const User = Object.create(Person)
User.email = ''
User.password = ''
User.getEmail = function() {
  return this.email
};
````

Затем мы можем создать экземпляр `User` с помощью `Object.create()`:

````js
let user = Object.create(User);
user.firstName = 'Dan';
user.lastName = 'Abramov';
user.email = 'dan@abramov.com';
user.password = 'iLuvES6';
````

Хитрость здесь заключается в использовании `Object.create()` для копирования. Объекты в **JavaScript** изменяемы, поэтому, когда вы используете присваивание для создания нового объекта и меняете второй объект, это изменяет и исходный объект. В качестве примера определим объект `Customer` с данными и функциями. Когда `User` станет клиентом `Customer`, мы хотим добавить к объекту `user` всё, что есть в `Customer`:

````js
const Customer = {
  plan: 'trial'
};

Customer.setPremium = function() {
  this.plan = 'premium'
};
````

Теперь мы можем добавить в объект `user` методы и поля `Customer`:

````js
User.customer = Customer;
user.customer.setPremium();
````

После выполнения этих двух строк объект `user` будет выглядеть так:

````js
{
 firstName: 'Dan',
 lastName: 'Abramov',
 email: 'dan@abramov.com',
 password: 'iLuvES6',
 customer: { plan: 'premium', setPremium: [Function] }
}
````

Когда мы захотим добавить ещё больше возможностей, объекты высшего уровня нам с этим всегда помогут.
***

## **Делегация**

перепоручение задачи от внешнего объекта внутреннему;

## **Агрегация**

включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование.

## **Не повторяйся (Don’t repeat yourself — DRY)**

Избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные. Каждая часть вашего кода или информации должна находиться в единственном числе в единственном доступном месте. Это один из принципов читаемого кода.

## **Принцип единственной обязанности**

Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

## **Принцип открытости/закрытости**

Программные сущности должны быть открыты для расширения, но закрыты для изменений.

## **Принцип подстановки Барбары Лисков**

Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.

## **Принцип разделения интерфейсов**

Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.

## **Принцип инверсии зависимостей**

Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.

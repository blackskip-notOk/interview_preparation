# **Равенство строгое и нестрогое**

Нестрогое равенство проверяется оператором `==`, а строгое оператором `===`. Оба оператора используются для сравнения двух значений на «равенство», но выбор формы (строгое/нестрогое) приводит к очень важным различиям в поведении, особенно в том, как принимается решение о равенстве.

* `==` допускает преобразование типа при проверке равенства
* `===` запрещает преобразование типа

***

## **Быстродействие проверки равенства**

* оператор `==` выполняет больше работы, потому что при различных типах ему приходится проходить через преобразование типа.
Хотя преобразование занимает какое-то время, оно занимает считаные микросекунды.

* Если вы сравниваете два значения одного типа, `==` и `===` используют идентичный алгоритм, поэтому если не считать мелких различий в реализации движка, они должны выполнять одну и ту же работу.

* Если вы сравниваете два значения разных типов, быстродействие не является важным фактором, важно понять нужно ли выполнялось преобразование типов или нет для конкретного блока кода.

* Оба оператора, `==` и `===`, проверяют типы своих операндов. Различие в том, как они реагируют на несовпадение типов.

***

## **Правила для строгого равенства**

1. Если два значения имеют различные типы, они не идентичны.

2. Если оба операнда являются значением `null` или `undefined`, они идентичны.

3. Если оба операнда являются логическим значением `true` или оба являются логическим значением `false`, они идентичны.

4. Если одно или оба значения являются значением `NaN`, они не идентичны.

5. Если оба значения являются числами с одним и тем же значением, они идентичны. Если один операнд имеет значение `0`, а другой `–0`, они также идентичны.

6. Если оба значения являются строками и содержат одни и те же 16-битные значения в одинаковых позициях, они идентичны. Если строки отличаются длиной или содержимым, они не идентичны. Две строки могут иметь один и тот же смысл и одинаково выглядеть на экране, но содержать отличающиеся последовательности 16-битных значений. Интерпретатор **JavaScript** не выполняет нормализацию символов Юникода, поэтому подобные пары строк не считаются операторами `===` и `==` ни равными, ни идентичными.

7. Если оба значения ссылаются на один и тот же объект, массив или функцию, то они идентичны. Если они ссылаются на различные объекты (массивы или функции), они не идентичны, даже если оба объекта имеют идентичные свойства.

***

## **Правила для нестрогого равенства**

Для понимания механизма действия оператора `==` нужно понимать как происходит [**приведение типов в js**](./type_coercion.md).

### **Абстрактная проверка равенства**

Поведение оператора `==` определяется в спецификации ES5 («Алгоритм абстрактной проверки равенства»). Когда кто-то осуждает (неявное) преобразование типа как слишком сложное и содержащее слишком много дефектов для полезного практического применения, он осуждает именно правила «абстрактной проверки равенства». Обычно говорят, что этот механизм слишком сложен и противоестественен для практического изучения и использования, и что он скорее создает в JS-программах ошибки, чем упрощает чтение кода.

***

Первый раздел cпецификации (11.9.3.1) утверждает, что, если два сравниваемых значения относятся к одному типу, они сравниваются простым и естественным способом. Например, `42` равно только `42`, а строка `"abc"` равна только `"abc"`.

Несколько второстепенных исключений, о которых следует помнить:

* Значение NaN никогда не равно само себе

* +0 и -0 равны друг другу

***

Последняя секция в разделе 11.9.3.1 посвящена нестрогой проверке равенства `==` с объектами (включая функции и массивы). Два таких значения равны только в том случае, если оба они ссылаются в точности на одно значение. Никакое преобразование
типа при этом не выполняется.

***

Строгая проверка равенства `===` определяется идентично 11.9.3.1, включая положение о двух объектных значениях. Этот факт очень малоизвестен, но `==` и `===` при сравнении двух объектов ведут себя полностью идентично.

***

Оставшаяся часть алгоритма в 11.9.3 указывает, что нестрогое равенство `==` может использоваться для сравнения двух разнотипных значений, одно или оба из которых потребуют неявного преобразования. В результате преобразования оба значения приводятся к одному типу, после чего они могут напрямую сравниваться на равенство по простой идентичности значений.

***

## **Сравнение: строки и числа**

```` js
var a = 42;
var b = "42";
a === b; // false
a == b; // true
````

В спецификации ES5 в разделах 11.9.3.4–5 говорится:

1. Если `Type(x)` относится к типу `Number`, а `Type(y)` относится к типу `String`, вернуть результат сравнения `x == ToNumber(y)`.

2. Если `Type(x)` относится к типу `String`, а `Type(y)` относится к типу `Number`, вернуть результат сравнения `ToNumber(x)` == `y`.

***

## **Сравнение: что угодно с логическими значениями**

Одна из самых опасных ловушек при неявном преобразовании типа `==` встречается при попытке прямого сравнения значения с `true` или `false`.

```` js
var a = "42";
var b = true;
a == b; // false
````

В спецификации ES5 в разделах 11.9.3.6–7 говорится:

1. Если `Type(x)` относится к типу `Boolean`, вернуть результат сравнения `ToNumber(x) == y`.

2. Если `Type(y)` относится к типу `Boolean`, вернуть результат сравнения `x == ToNumber(y)`.

Первый шаг:

```` js
var x = true;
var y = "42";
x == y; // false
````

`Type(x)` действительно относится к типу `Boolean`, поэтому выполняется операция `ToNumber(x)`, которая преобразует `true` в `1`. Теперь вычисляется условие `1 == "42"`. Типы все равно различны, поэтому (фактически рекурсивно) алгоритм повторяется => как и в предыдущем случае, `"42"` преобразуется в `42`, а условие `1 == 42` очевидно ложно.

Если поменять операнды местами, результат останется прежним:

```` js
var x = "42";
var y = false;
x == y; // false
````

На этот раз `Type(y)` имеет тип `Boolean`, так что `ToNumber(y)` дает `0`. Условие `"42" == 0` рекурсивно превращается в `42 == 0`, что, ложно.

Другими словами, значение `"42"` ни `==` `true`, ни `==` `false`.

Значение `"42"` действительно истинно, но конструкция `"42" == true` вообще не выполняет проверку boolean/преобразование, что бы там ни говорил ваш мозг. `"42"` не преобразуется в `boolean`, вместо этого `true` преобразуется в `1`, а затем `"42"` преобразуется в `42`.

***

## **Сравнение: null с undefined**

Другой пример неявного преобразования встречается при использовании нестрогой проверки равенства `==` между значениями `null` и `undefined`.

В спецификации ES5 в разделах 11.9.3.2–3 говорится:

1. Если `x` содержит `null`, а `y` содержит `undefined`, вернуть `true`.

2. Если `x` содержит `undefined`, а y содержит `null`, вернуть `true`.

`Null` и `undefined` при сравнении нестрогим оператором `==` равны друг другу (то есть преобразуются друг к другу), и никаким другим значениям во всем языке.

```` js
var a = null;
var b;
a == b; // true
a == null; // true
b == null; // true
a == false; // false
b == false; // false
a == ""; // false
b == ""; // false
a == 0; // false
b == 0; // false
````

***

## **Сравнение: объекты и необъекты**

Если объект/функция/массив сравнивается с простым скалярным примитивом (`string`, `number` или `boolean`), в спецификации ES5 говорится следующее (раздел 11.9.3.8–9):

1. Если `Type(x)` относится к типу `String` или `Number`, а `Type(y)` относится к типу `Object`, вернуть результат сравнения `x == ToPrimitive(y)`.

2. Если `Type(x)` относится к типу `Object`, а `Type(y)` относится к типу `String` или `Number`, вернуть результат сравнения `ToPrimitive(x) == y`.

Разделы 11.9.3.6–7 гарантируют, что любой операнд `Boolean` был сначала представ-
лен в виде `Number`.

```` js
var a = 42;
var b = [ 42 ];
a == b; // true
````

Для значения `[ 42 ]` вызывается абстрактная операция `ToPrimitive`, которая дает результат `"42"`. С этого момента остается простое условие `"42" == 42`, которое, превращается в `42 == 42`, так что `a` и `b` равны с точностью до преобразования типа.

***

## **Особые случаи**

### **Изменение свойств в объекте prototype**

```` js
if (a == 2 && a == 3) {
 // ..
}
````

Выражение «одновременно» в данном случае неточно, так как первое выражение `a == 2`
вычисляется строго ранее `a == 3`.

```` js
var i = 2;

Number.prototype.valueOf = function() {
 return i++;
};

var a = new Number( 42 );

if (a == 2 && a == 3) {
 console.log( "Да, это случилось." );
}
````

***

## **Сравнения ложных значений**

Самые распространенные претензии к неявным преобразованиям при сравнениях `==` происходят от странностей поведения ложных значений при сравнении их друг с другом.

```` js
"0" == null; // false
"0" == undefined; // false
"0" == NaN; // false
"0" == 0; // true
"0" == ""; // false
false == null; // false
false == undefined; // false
false == NaN; // false
false == {}; // false
"" == null; // false
"" == undefined; // false
"" == NaN; // false
"" == {}; // false
0 == null; // false
0 == undefined; // false
0 == NaN; // false
0 == {}; // false
[] == ![]; // true
2 == [2]; // true
"" == [null]; // true
0 == "\n"; // true
````

Список "плохих" преобразований (приведение типов работает по стандартному механизму, если проследить пощаговый алгоритм, то всё более-менее логично):

```` js
"0" == false; // true – ОЙ-ОЙ!
false == 0; // true – ОЙ-ОЙ!
false == ""; // true – ОЙ-ОЙ!
false == []; // true – ОЙ-ОЙ!
"" == 0; // true – ОЙ-ОЙ!
"" == []; // true – ОЙ-ОЙ!
0 == []; // true – ОЙ-ОЙ!
````

Пара эвристических правил поможет избежать проблем с такими сравнениями:

* Если в одной из частей сравнения может находиться значение `true` или `false` НИКОГДА не используйте `==`.

* Если в одной из частей сравнения может находиться значение `[]`, `""` или `0`, постарайтесь обойтись без использования `==`.

В этих сценариях практически всегда лучше использовать `===` вместо `==`, чтобы избежать нежелательных преобразований типов.

В общем и целом, случаи, в которых неявное преобразование действительно опасно, относительно немногочисленны. Но в таких случаях для безопасности определенно следует использовать `===`. Другое место, в котором преобразование типа гарантирован
но вас не подведет, — оператор `typeof`. `Typeof` всегда возвращает одну из семи строк, ни одна из которых не является пустой строкой `""`. Соответственно ни в каком случае проверка типа некоторого значения не пойдет насмарку из-за неявного преобразования. Условие `typeof x == "function"` на 100% так же безопасно и надежно, как и условие `typeof x === "function"`. В спецификации указано, что в этих ситуациях применяются идентичные алгоритмы.

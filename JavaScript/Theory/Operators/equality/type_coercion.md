# **Преобразование типов**

Приведение типов (type coercion) — это автоматическое или неявное преобразование значений из одного типа данных в другой (например, строки в число).

Любая попытка использовать `null` и `undefined` в контексте, где требуется объект, вместо преобразования будет приводить к возбуждению исключения `TypeError`.

***

## **Преобразование значений**

Преобразование значения от одного типа к другому часто делится на явное (выполняемое напрямую) и неявное (обусловленное правилами использования этого значения).

### **Абстрактные операции**

Спецификация ES5 в разделе 9 определяет несколько «абстрактных операций» (хитроумный термин, обозначающий «операции только для внутреннего использования») с правилами преобразования значений.

## **ToString**

Когда любое нестроковое значение преобразуется в строковое представление, преобразование выполняется абстрактной операцией `ToString`. Встроенные примитивные значения содержат естественное преобразование к строковому виду:

* `null` превращается в `"null"`,

* `undefined` превращается в `"undefined"`,

* `true` превращается в `"true"`.

* Числа обычно выражаются в естественном виде, но очень малые или очень большие числа представляются в экспоненциальной форме:

```` js
// `1.07` умножается на `1000` семь раз
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;
// семь раз по три цифры = 21 цифра
a.toString(); // "1.07e21"
````

* [Преобразование объектов](#преобразование-объектов-в-строку)

***

## **Преобразование `JSON` в строку**

Другая задача, также тесно связанная с `ToString`, — использование метода `JSON.stringify()` для сериализации значения в `JSON`-совместимое строковое значение. Важно заметить, что задача `stringify()` несколько отличается
от преобразования в строку.

Для большинства простых значений преобразование `JSON` ведет себя практически так же, как преобразования `toString()`, если не считать того, что результатом сериализации всегда является строка:

```` js
JSON.stringify( 42 ); // "42"
JSON.stringify( "42" ); // ""42"" (строка с заключенным
 // в кавычки строковым значением)
JSON.stringify( null ); // "null"
JSON.stringify( true ); // "true"
````

Любое JSON-безопасное значение может быть преобразовано вызовом `JSON.stringify()`. «JSON-безопасным» считается любое значение, которое имеет действительное представление в формате `JSON`.

Значения которые не являются JSON-безопасными:

* undefined,

* функции,

* символические имена,
* объекты с циклическими ссылками (свойства в объектной структуре ссылаются
друг на друга, создавая бесконечный цикл).

Все эти значения недопустимы в стандартной структуре `JSON`, прежде всего потому, что они не портируются на другие языки, потребляющие значения `JSON`.

Метод `JSON.stringify()` автоматически опускает обнаруженные значения `undefined`, `function` и `symbol`. Если такое значение будет найдено в массиве, оно заменяется `null` (чтобы положение информации в массиве не изменилось). Если значение обнаруживается в свойстве объекта, это свойство просто исключается.

```` js
JSON.stringify( undefined ); // undefined
JSON.stringify( function(){} ); // undefined
JSON.stringify( [1,undefined,function(){},4] ); // "[1,null,null,4]"
JSON.stringify( { a:2, b:function(){} } ); // "{"a":2}"
````

Но если попытаться вызвать `JSON.stringify()` с объектом, содержащим циклические ссылки, произойдет ошибка.

У преобразования `JSON` есть особое поведение: если у значения `object` определен метод `toJSON()`, сначала будет вызван этот метод. Он дает значение, которое должно использоваться для сериализации.

В `JSON.stringify()` может передаваться необязательный второй аргумент,который называется заменителем (replacer). Этим аргументом может быть массив или функция. Он предназначен для настройки рекурсивной сериализации объекта и предоставляет механизм фильтрации свойств, которые должны (или не должны)
включаться в результат, по аналогии с тем, как `toJSON()` готовит значение для сериализации.

* Если заменитель является массивом, это должен быть массив
строк, каждая из которых задает имя свойства, разрешенного для включения в сериализацию объекта. Если какое-то свойство не входит в этот список, оно пропускается.

* Если заменитель является функцией, эта функция сначала будет вызвана для самого объекта, а затем для каждого свойства в объекте; каждый раз ей передаются два аргумента, ключ и значение. Чтобы пропустить ключ в сериализации, верните `undefined`. В противном случае верните значение.

```` js
var a = {
 b: 42,
 c: "42",
 d: [1,2,3]
};
JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
JSON.stringify( a, function(k,v){
 if (k !== "c") return v;
} ); // "{"b":42,"d":[1,2,3]}"
````

В случае заменителя-функции аргумент ключа k не определен для первого вызова (при котором передается сам объект a). Команда if отфильтровывает свойство с именем «c». Преобразование в строку выполняется рекурсивно, так что каждое из значений массива [1,2,3] передается заменителю в аргументе v, а индексы (0, 1 и 2) передаются в аргументе k.

`JSON.stringify(..)` также может передаваться третий необязательный аргумент отступ, который используется для украшения вывода. Отступ может быть положительным целым числом — тогда он указывает, сколько пробелов должно использоваться на каждом уровне отступов. Также отступ может быть строкой;
в этом случае на каждом уровне отступов используются его начальные символы (до 10):

```` js
var a = {
 b: 42,
 c: "42",
 d: [1,2,3]
};
JSON.stringify( a, null, 3 );
// "{
// "b": 42,
// "c": "42",
// "d": [
// 1,
// 2,
// 3
// ]
// }"
JSON.stringify( a, null, "-----" );
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
````

`JSON.stringify()` не является прямой формой преобразования типа. Причины связывающие его поведение с преобразованием `ToString`:

1. Значения `string`, `number`, `boolean` и `null` преобразуются для `JSON` практически так же, как они преобразуются в строковые значения по правилам абстрактной операции `ToString`

2. Если передать `JSON.stringify()` объектное значение, и у этого объекта определен метод `toJSON()`, он автоматически будет вызываться для «приведения» значения в JSON-безопасное перед преобразованием в строковую форму

***

## **ToNumber**

Спецификация ES5 определяет абстрактную операцию `ToNumber` в разделе 9.3.

* `true` преобразуется в `1`,
* `false` преобразуется в `0`,
* `undefined` превращается в `NaN`,
* `null` превращается в `0`.

* `ToNumber` для строкового значения большей частью работает по аналогии с правилами/синтаксисом числовых литералов. Строки, которые могут быть преобразованы в числа, преобразуются в числа. В строке допускается наличие пробельных символов в начале и в конце, но присутствие других непробельных символов, которые не могут быть частью числа, при преобразовании строки в число приводят к возврату значения `NaN`. Если попытка завершается неудачей, то результат равен `NaN` (вместо синтаксической ошибки, как в случае с числовыми литералами).
Одно из отличий заключается в том, что восьмеричные числа с префиксом `0` в этой операции обрабатываются не как восьмеричные, а как обычные десятичные, хотя такие восьмеричные числа являются действительными, как числовые литералы.

* [Преобразование объектов](#преобразование-объекта-в-число)

***

## **ToBoolean**

Все значения **JavaScript** можно разделить на две категории:

* Значения, которые при преобразовании в `boolean` дают `false`.

* Все остальные (которые, очевидно, дают `true`).

В спецификации ES5 в разделе 9.2 определена абстрактная операция `ToBoolean`, которая точно говорит, что происходит со всеми возможными значениями при попытке преобразования их в `boolean`.
Из этой таблицы мы получаем следующий список так называемых «ложных» значений:

1. `undefined`
2. `null`
3. `false`
4. `+0`
5. `-0`
6. `NaN`
7. `""`

Если значение присутствует в списке, оно является «ложным», и при применении преобразования к логическому типу вы получите `false`.
Логика подсказывает, что, если значение не входит в этот список, оно должно входить в другой список, «истинных» значений. Но спецификация JS не определяет «истинный» список как таковой. Она содержит некоторые примеры (например, в ней явно указано, что все объекты являются истинными), но в основном спецификация просто подразумевает, что все значения, не входящие
в список ложных, являются истинными.

### **Ложные объекты**

```` js
var a = new Boolean( false );
var b = new Number( 0 );
var c = new String( "" );
var d = Boolean( a && b && c );
d; // true
````

Все три значения являются объектами, в которых обернуты явно ложные значения,
все три интерпретируются как `true`.

В некоторых ситуациях браузеры создают собственное экзотическое поведение для некоторых значений, а именно понятие «ложных объектов» поверх обычной семантики JS.

«Ложный объект» представляет собой значение, которое выглядит и работает как нормальный объект (свойства и все такое), но при попытке преобразования к `boolean` дает `false`.

Самый известный случай такого рода — `document.all`; этот объект (аналог массива) предоставляется вашей JS-программе JS-моделью `DOM` (не самим движком JS) и предоставляет элементы страницы вашей JS-программе. Когда-то он вел себя как обычный объект и действовал как истинное значение. Сейчас все изменилось. Объект `document.all` никогда не считался «стандартным» и уже давно считается устаревшим/не поддерживаемым.
Его "застявляют" действовать как ложный, потому что преобразования `document.all` в `boolean` (обычно в командах `if`) почти всегда используются как способ выявления старого, нестандартного `IE`.

***

## **Преобразование символических имен**

Явное преобразование символического имени в строку разрешено, но такое же неявное преобразование запрещено, а при попытке его выполнения происходит ошибка.

```` js
var s1 = Symbol( "cool" );
String( s1 ); // "Symbol(cool)"

var s2 = Symbol( "not cool" );
s2 + ""; // TypeError
````

Значения `symbol` вообще невозможно преобразовать в `number` (в любом случае происходит ошибка), но, как ни странно, они могут явно и неявно преобразовываться к `boolean` (результат всегда равен `true`).

***

## **Преобразования объектов**

### **Преобразование объектов в логические значения**

Все объекты (включая массивы и функции) преобразуются в значение true. Это справедливо и для объектов-оберток: результатом вызова new Boolean(false) является объект, а не простое значение, поэтому он также преобразуется в значение true.

***

### **Преобразование объекта в строку и преобразование объекта в число**

Объекты в языке **JavaScript** имеют два разных метода для выполнения преобразований, а также наличием нескольких специальных случаев. Правила преобразования объектов в строки и числа, применяются только к объектам самого языка **JavaScript**. Объекты среды выполнения (например, определяемые веб-браузерами) могут предусматривать собственные алгоритмы преобразования в числа и строки.

**Все объекты наследуют два метода преобразования:**

* **Первый из них называется `toString()`, он возвращает строковое представление объекта.**

```` js
({x:1, y:2}).toString() // => "[object Object]"
````

Многие классы определяют более специализированные версии метода `toString()`.

* Метод `toString()` класса `Array` преобразует все элементы массива в строки и объединяет результаты в одну строку, вставляя запятые между ними.

* Метод `toString()` класса `Function` возвращает строковое представление функции, зависящее от реализации. На практике обычно реализации преобразуют пользовательские функции в строки с исходным программным кодом на языке **JavaScript**.

* Класс `Date` определяет метод `toString()`, возвращающий строку с датой и временем в удобочитаемом формате (который может быть разобран средствами **JavaScript**).

* Класс `RegExp` определяет метод `toString()`, преобразующий объект `RegExp` в строку, которая выглядит как литерал регулярного выражения:

```` js
[1,2,3].toString() // => "1,2,3"

(function(x) { f(x); }).toString() // => "function(x) {\n f(x);\n}"

/\d+/g.toString() // => "/\\d+/g"

new Date(2010,0,1).toString() // => "Fri Jan 01 2010 00:00:00 GMT+0300"
````

* **Метод valueOf(): предполагается, что он должен преобразовать объект в представляющее его простое значение, если такое значение существует.**

* Объекты по своей природе являются составными значениями, и большинство объектов не могут быть представлены в виде единственного простого значения, поэтому по умолчанию метод `valueOf()` возвращает не простое значение, а сам объект.

* Классы-обертки определяют методы `valueOf()`, возвращающие обернутые простые значения.

* Массивы, функции и регулярные выражения наследуют метод по умолчанию. Вызов метода `valueOf()` экземпляров этих типов возвращает сам объект.

* Класс `Date` определяет метод `valueOf()`, возвращающий дату во внутреннем пред-
ставлении: количество миллисекунд, прошедших с 1 января 1970 года:

```` js
var d = new Date(2010, 0, 1); // 1 ян­ва­ря 2010 го­да, (вре­мя Мо­с­ков­ское)

d.valueOf() // => 1262293200000
````

***

### **Преобразование объектов в строку**

Выполняет в два этапа:

• Если объект имеет метод `toString()`, интерпретатор вызывает его. Если он возвращает простое значение, интерпретатор преобразует значение в строку (если
оно не является строкой) и возвращает результат преобразования.

• Если объект не имеет метода `toString()` или этот метод не возвращает простое
значение, то интерпретатор проверяет наличие метода `valueOf()`. Если этот метод определен, интерпретатор вызывает его. Если он возвращает простое значение, интерпретатор преобразует это значение в строку (если оно не является строкой) и возвращает результат преобразования.

• В противном случае интерпретатор делает вывод, что ни `toString()`, ни `valueOf()`
не позволяют получить простое значение и возбуждает исключение `TypeError`.

### **Преобразование объекта в число**

Интерпретатор выполняет те же действия, но первым пытается применить метод `valueOf()`:

• Если объект имеет метод `valueOf()`, возвращающий простое значение, интерпретатор преобразует (при необходимости) это значение в число и возвращает результат.

• Иначе, если объект имеет метод `toString()`, возвращающий простое значение,интерпретатор выполняет преобразование и возвращает полученное значение.

• В противном случае возбуждается исключение `TypeError`.

Описанный алгоритм преобразования объекта в число объясняет, почему пустой массив преобразуется в число `0`, а массив с единственным элементом может быть преобразован в обычное число. Массивы наследуют по умолчанию метод `valueOf()`,
который возвращает сам объект, а не простое значение, поэтому при преобразовании массива в число интерпретатор опирается на метод `toString()`. Пустые массивы преобразуются в пустую строку. А пустая строка преобразуется в число `0`.
Массив с единственным элементом преобразуется в ту же строку, что и единственный элемент массива. Если массив содержит единственное число, это число преобразуется в строку, а затем опять в число.

Оператор `+` в языке **JavaScript** выполняет сложение чисел и конкатенацию строк.
Если какой-либо из его операндов является объектом, **JavaScript** преобразует
объект, используя специальное преобразование объекта в простое значение вместо преобразования объекта в число, используемого другими арифметическими операторами. То же относится и к оператору равенства `==`. Если выполняется сравнение объекта с простым значением, оператор выполнит преобразование объекта с использованием правил преобразования в простое значение. Преобразование объектов в простые значения, используемое операторами `+` и `==`, предусматривает особый подход для объектов `Date`. Класс `Date` является единственным типом данных в базовом **JavaScript**, который определяет осмысленные преобразования и в строку, и в число. Преобразование любого объекта, не являющегося датой, в простое значение основано на преобразовании в число (когда первым применяется метод `valueOf()`), тогда как для объектов типа Date используется преобразование в строку (первым применяется метод `toString()`). Однако преобразование выполняется не совсем так, как было описано выше: простое значение, возвращаемое методом `valueOf()` или `toString()`, используется непосредственно, без дополнительного преобразования в число или в строку.
Оператор `<` и другие операторы отношений выполняют преобразование объектов в простые значения подобно оператору `==`, но не выделяя объекты `Date`: для любого
объекта сначала предпринимается попытка применить метод `valueOf()`, а затем
метод `toString()`. Любое простое значение, полученное таким способом, используется непосредственно, без дальнейшего преобразования в число или в строку.
`+`, `==`, `!=` и операторы отношений являются единственными, выполняющими специальное преобразование строки в простое значение. Другие операторы выполняют более явные преобразования в заданный тип и не предусматривают специальной обработки объектов `Date`. Оператор `-`, например, преобразует свои операнды в числа. Следующий фрагмент демонстрирует поведение операторов `+`, `-`, `==`
и `>` при работе с объектами `Date`:

```` js
var now = new Date(); // Соз­дать объ­ект Date

typeof (now + 1) // => "стро­ка": + пре­об­ра­зу­ет да­ту в стро­ку

typeof (now - 1) // => "чис­ло": - вы­пол­нит пре­об­ра­зо­ва­ние объ­ек­та в чис­ло

now == now.toString() // => true: не­яв­ное и яв­ное пре­об­ра­зо­ва­ние в стро­ку

now > (now -1) // => true: > пре­об­ра­зу­ет объ­ект Date в чис­ло

````

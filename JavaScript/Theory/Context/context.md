# **This**

## **Ссылки**

* [**Что такое `this`**](#что-такое-this)
* [**Место вызова функции**](#место-вызова-функции)
* [**Парвила определения `this`**](#парвила-определения-this)
* [**Приоритет правил связывания `this**](#приоритет-правил-связывания-this)
* [**Определение `this`**](#определение-this)
* [**Игнорирование this**](#игнорирование-this)
* [**Лексическое поведение `this`**](#лексическое-поведение-this)
* [**Задача - Счетчик вызова функции**](#счетчик-вызова-функции-с-использованием-this)
* [**Решение задачи путём создания объекта для хранения свойства `count`**](#решение-задачи-без-использования-this-путём-создания-объекта-для-хранения-свойства-count)
* [**Решение задачи путём использования идентификатора `foo` как ссылку на объект функции**](#решение-задачи-без-использования-this-путём-использования-идентификатора-foo-как-ссылку-на-объект-функции)
* [**Решение задачи с использованием `this`**](#решение-задачи-с-использованием-this)

***

Ключевое слово `this` обозначает специальный идентификатор, который автоматически определяется в области видимости каждой функции.
***

## **Что такое `this`**

Связывание `this` осуществляется не во время написания программы, а во время выполнения.Связывание является контекстным, то есть базируется на условиях вызова функции. Связывание `this` не имеет никакого отношения к тому, где была объявлена функция, но полностью определяется способом вызова этой функции. При вызове функции создается запись активации, также называемая контекстом выполнения. Запись содержит информацию о том, откуда была вызвана функция (стек вызовов), как она была вызвана, какие параметры были переданы при вызове и т. д. Одним из свойств этой записи является ссылка `this`, которая используется на протяжении выполнения этой функции.
***

## **Место вызова функции**

Место вызова (call-site) - позицию кода, в которой вызывается функция (а не ту, где она была объявлена). Необходимо проанализировать место вызова, чтобы ответить на вопрос: на что указывает ссылка `this`?
Поиск места вызова в общем случае означает «найти точку, из которой вызывается функция», что порой может оказаться непросто, так как некоторые паттерны программирования могут скрыть истинное место вызова. При этом важно учитывать стек вызовов (то есть стек функций, которые были вызваны для того, чтобы выполнение дошло до своего текущего состояния). Место вызова, которое нас интересует, — вызов непосредственно перед текущей выполняемой функцией.

Концепции стека вызовов и точки вызова:

```` js
function baz() {
 // Стек вызовов: `baz`
 // Следовательно, место вызова принадлежит глобальной
 // области видимости
 console.log( "baz" );
 bar(); // <-- Место вызова для `bar`
}

function bar() {
 // Стек вызовов: `baz` -> `bar`
 // Следовательно, место вызова находится в `baz`
 console.log( "bar" );

 foo(); // <-- Место вызова для `foo`
}

function foo() {
 // Стек вызовов: `baz` -> `bar` -> `foo`
 // Следовательно, место вызова находится в `bar`
 console.log( "foo" );
}

baz(); // <-- Место вызова для `baz`
````

Анализируя код для поиска фактического места вызова (из стека вызовов), будьте внимательны, потому что это единственное, что влияет на связывание this.

Чтобы мысленно представить стек вызовов, можно последовательно рассмотреть цепочку вызовов функций, как это было сделано в комментариях в предыдущем примере. Другой способ просмотра стека вызовов основан на использовании отладчика в браузере. В предыдущем фрагменте кода можно установить в отладчике точку прерывания в первой строке функции foo().
***

## **Парвила определения `this`**

1. ### **Связывание по умолчанию**

    Первое правило происходит от самого распространенного случая вызовов функций: автономных вызовов функций. Это правило будет использовано
    по умолчанию, если не применяется ни одно из других правил.

    ```` js
    function foo() {
        console.log( this.a );
    }

    var a = 2;

    foo(); // 2
    ````

    Первое, на что следует обратить внимание, — на переменные, объявленные в глобальной области видимости (например, `var a = 2`): они имеют синонимы
    виде одноименных свойств глобального объекта. Они не являются независимыми копиями, это просто одно и то же, что-то вроде двух сторон одной монеты. Кроме того, мы видим, что при вызове `foo()` конструкция `this.a` превращается в глобальную переменную `a`. Потому, что
    в этом случае связывание по умолчанию `this` применяется к вызову функции, а следовательно, `this` указывает на глобальный объект. Аализируем место вызова и смотрим, как вызывается `foo()`. В фрагменте `foo()` вызывается с простой, неизмененной ссылкой на функцию. Никакие другие правила (которые будут приведены ниже) здесь не применимы, поэтому в данном случае применяется связывание по умолчанию. Если действует режим `strict`, глобальный объект не может использоваться для связывания по умолчанию, поэтому `this` вместо этого присваивается `undefined`:

    ```` js
    function foo() {
        "use strict";
        console.log( this.a );
    }

    var a = 2;

    foo(); // TypeError: `this` is `undefined`
    ````

    Тонкая, но важная подробность: хотя в целом эти правила связывания полностью зависят от места вызова, глобальный объект доступен для связывания по умолчанию только в том случае, если содержимое `foo()` не выполняется в режиме `strict`; действие режима `strict` для места вызова `foo()` роли не играет:

    ```` js
    function foo() {
        console.log( this.a );
    }

    var a = 2;

    (function(){
        "use strict";

        foo(); // 2
    })();
    ````

    Как правило, намеренно смешивать в коде части с включенным и отключенным режимом `strict` не рекомендуется.
    ***

2. ### **Неявное связывание**

    Другое правило, которое необходимо учитывать, — наличие у места вызова контекстного объекта, также называемого владельцем (owner) или содержащим объектом.

    ```` js
    function foo() {
        console.log( this.a );
    }

    var obj = {
        a: 2,
        foo: foo
    };

    obj.foo(); // 2
    ````

    Сначала обратите внимание на то, как `foo()` объявляется, а затем добавляется как ссылочное свойство в `obj`. Независимо от того, объявляется ли `foo()` для `obj` изначально или же добавляется как ссылка позднее (как в приведенном фрагменте), ни в одном из случаев объект `obj` не является «владельцем» функции и не «содержит» ее. Тем не менее место вызова использует контекст `obj` для создания ссылки на функцию, поэтому можно сказать, что объект `obj` является «владельцем» или «содержит» ссылку на функцию на момент ее вызова. Когда при обращении к функции указывается контекстный объект, правило неявного связывания требует, чтобы этот объект использовался для связывания `this` данного вызова функции. Поскольку `obj` становится `this` для вызова `foo()`, синтаксис `this.a` является синонимом `obj.a`.
    Для места вызова важен только верхний/последний уровень цепочки ссылок на свойства объекта.

    ```` js
    function foo() {
        console.log( this.a );
    }

    var obj2 = {
        a: 42,
        foo: foo
    };

    var obj1 = {
        a: 2,
        obj2: obj2
    };

    obj1.obj2.foo(); // 42
    ````

    #### **Неявная потеря this**

    Одна из самых распространенных проблем, возникающих при связывании, — когда функция с неявным связыванием теряет это связывание, что обычно означает возврат к связыванию по умолчанию — глобальному объекту или `undefined` в зависимости от действия режима `strict`.

    ```` js
    function foo() {
     console.log( this.a );
    }

    var obj = {
     a: 2,
     foo: foo
    };

    var bar = obj.foo; // Ссылка на функцию/синоним!

   var a = "oops, global"; // `a` также является свойством глобального объекта
    bar(); // "oops, global"
    ````

    И хотя `bar` кажется ссылкой на `obj.foo`, в действительности это всего лишь еще одна ссылка на саму функцию `foo`. Кроме того, важно только место вызова, а здесь оно имеет вид `bar()` — простой вызов без префикса, а следовательно, здесь применяется связывание по умолчанию. Более тонкий, более распространенный и более неожиданный пример встречается при передаче функции обратного вызова:

    ````js
    function foo() {
     console.log( this.a );
    }

    function doFoo(fn) {
     // `fn` - просто еще одна ссылка на `foo`
     fn(); // <-- место вызова!
    }

    var obj = {
     a: 2,
     foo: foo
    };

    var a = "oops, global"; // `a` также является свойством глобального объекта
    doFoo( obj.foo ); // "oops, global"
    ````

    Передача параметров — всего лишь неявное присваивание, а поскольку мы передаем функцию, происходит неявное присваивание ссылки, поэтому конечный результат будет таким же, как в предыдущем фрагменте.
    ***

3. ### **Явное связывание**

    Все функций в языке содержат методы `call(..)` и `apply(..)`. Они получают в первом параметре объект, который должен использоваться для `this`, а затем вызывают функцию с заданным значением `this`.

    ```` js
    function foo() {
        console.log( this.a );
    }

    var obj = { a: 2 };

    foo.call( obj ); // 2
    ````

    Вызов `foo` с явным связыванием `foo.call(..)` позволяет принудительно задать его `this` значение `obj`. Если передать простое примитивное значение (типа `string`, `boolean` или `number`) для связывания `this`, это примитивное значение будет преобразовано в объектную форму (`new String(..)`, `new Boolean(..)` или `new Number(..)` соответственно). Часто это преобразование называется упаковкой (boxing). В отношении связывания `this` поведение `call(..)` и `apply(..)` идентично.
    К сожалению, явное связывание также не решает проблему, упоминавшуюся ранее — [«потерю» функцией ее предполагаемого связывания `this`](#неявная-потеря-this).
    ***

4. ### **Жесткое связывание**

    Существует паттерн на базе явного связывания, который решает [эту проблему](#неявная-потеря-this).

    ```` js
    function foo() {
        console.log( this.a );
    }

    var obj = { a: 2 };

    var bar = function() {
        foo.call( obj );
    };

    bar(); // 2

    setTimeout( bar, 100 ); // 2
    // У жестко связанной функции `bar` значение `this` не может заменяться

    bar.call( window ); // 2
    ````

    Создаем функцию `bar()`, которая во внутренней реализации вручную вызывает `foo.call(obj)`, принудительно вызывая `foo` со связыванием `obj` для `this`. Неважно, как позднее будет вызываться функция `bar` — она всегда вручную будет вызывать `foo` c `obj`. Такой способ связывания явно выражен и надежен; Самый типичный способ упаковки функции с жестким связыванием создает сквозную передачу любых переданных аргументов и полученного возвращаемого значения:

    ```` js
    function foo(something) {
        console.log( this.a, something );
        return this.a + something;
    }

    var obj = { a: 2 };

    var bar = function() {
        return foo.apply( obj, arguments );
    };

    var b = bar( 3 ); // 2 3
    console.log( b ); // 5
    ````

    Другой способ выражения этого паттерна основан на создании вспомогательной функции, пригодной для повторного использования:

    ```` js
    function foo(something) {
        console.log( this.a, something );
        return this.a + something;
    }

    // Простая вспомогательная функция `bind`

    function bind(fn, obj) {
        return function() {
            return fn.apply( obj, arguments );
        };
    }

    var obj = { a: 2 };

    var bar = bind( foo, obj );

    var b = bar( 3 ); // 2 3
    console.log( b ); // 5
    ````

    Так как жесткое связывание является чрезвычайно распространенным паттерном, в ES5 для него была определена встроенная реализация `Function.prototype.bind`, которая используется следующим образом:

    ```` js
    function foo(something) {
        console.log( this.a, something );
        return this.a + something;
    }

    var obj = { a: 2 };

    var bar = foo.bind( obj );

    var b = bar( 3 ); // 2 3
    console.log( b ); // 5
    ````

    `bind(..)` возвращает новую функцию, жестко запрограмированную для вызова исходной функции с заданным контекстом `this`.
    ***

5. ### **Связывание new**

    Последнее правило связывания `this` заставляет пересмотреть очень распространенное заблуждение, касающееся функций и объектов в **JavaScript**.
    В традиционных языках, основанных на использовании классов, «конструкторы» представляют собой специальные методы, присоединенные к классам. При создании экземпляра класса оператором `new` вызывается конструктор этого класса. В **JavaScript** существует оператор `new`, а паттерн его использования почти не отличается от того, что мы видим в языках с использованием классов. Однако на самом деле использование `new` в **JS** не имеет отношения к функциональности, относящейся к классам.
    Сначала определим понятие «конструктора» в **JavaScript**. В **JS** конструкторы представляют собой обычные функции, которые вызываются с указанием оператора `new` перед ними. Они не присоединяются к классам и не создают их экземпляры. Они даже не являются особой разновидностью функций. Это самые обычные функции, которые наделяются новым смыслом из-за использования `new` при их вызове. Такого понятия, как «функция-конструктор», не существует. Существуют вызовы — конструкторы функций. Когда функция вызывается после оператора `new` (такие вызовы
    называются вызовами-конструкторами), автоматически выполняются следующие действия:

    1. Создается (конструируется) новый объект.

    2. Производится связывание сконструированного объекта с `[[Prototype]]`.

    3. Сконструированный объект назначается в качестве связывания `this` для этого вызова функции.

    4. Если функция не возвращает свой альтернативный объект, вызов функции автоматически возвращает сконструированный объект.

    ``` js
    function foo(a) {
        this.a = a;
    }

    var bar = new foo( 2 );

    console.log( bar.a ); // 2
    ````

    Вызывая `foo(..)` после `new`, мы конструируем новый объект и назначаем его в качестве значения `this` для вызова `foo(..)`.

## **Приоритет правил связывания `this**

* [правило связывания по умолчанию](#1--связывание-по-умолчанию) имеет самый низкий приоритет.

* [неявное связывание](#2--неявное-связывание).

* [явное связывание](#3--явное-связывание) приоритетнее неявного.

* [связывание new](#5--связывание-new) обладает более высоким приоритетом,
чем [неявное](#2--неявное-связывание), [явное](#3--явное-связывание) и [жесткое](#4--жесткое-связывание).

## **Определение `this`**

1. Функция вызвана с `new` Если да, то `this` содержит новый сконструированный объект. `var bar = new foo()`

2. Функция вызвана с `call` или `apply`, даже скрытыми в жесткой привязке `bind`? Если да, то `this` содержит явно заданный объект. `var bar = foo.call( obj2 )`

3. Функция вызвана с контекстом также называемым объектом-владельцем или содержащим объектом?
Если да, то `this` содержит контекстный объект. `var bar = obj1.foo()`

4. В остальных случаях используется `this` по умолчанию. Если действует режим `strict`,  `undefined`, а если нет — глобальный объект: `var bar = foo()`

## **Игнорирование this**

Если передать `call`, `apply` или `bind` в параметре связывания `this` значение `null` или `undefined`, эти значения фактически игнорируются, и к вызову применяется правило связывания по умолчанию:

```` js
function foo() {
 console.log( this.a );
}

var a = 2;

foo.call( null ); // 2
````

`apply(..)` довольно часто применяется для распределения массивов значений по параметрам вызова функций. Также `bind()` может выполнять каррирование параметров, что может быть очень полезно:

```` js
function foo(a,b) {
 console.log( "a:" + a + ", b:" + b );
}
// Распределение массива по параметрам
foo.apply( null, [2, 3] ); // a:2, b:3
// Каррирование вызовом `bind(..)`
var bar = foo.bind( null, 2 );
bar( 3 ); // a:2, b:3
````

Обе функции требуют передачи связывания `this` в первом параметре. Если сами функции не обращают внимания на `this`, понадобится значение-заполнитель; как показывает этот фрагмент,
`null` может показаться разумным кандидатом.

## **Лексическое поведение `this`**

Стрелочные функции принимают связывание `this` от внешней области видимости (функциональной
или глобальной).

```` js
function foo() {
 // Вернуть стрелочную функцию
 return (a) => {
 // `this` здесь лексически наследуется от `foo()`
 console.log( this.a );
 };
}

var obj1 = { a: 2 };

var obj2 = { a: 3 };

var bar = foo.call( obj1 );

bar.call( obj2 ); // 2, не 3!
````

Стрелочная функция, созданная в `foo()`, лексически захватывает значение `this` функции `foo()` на момент вызова. Так как `foo()` была связана по `this` с `obj1`, `bar` (ссылка на возвращенную стрелочную функцию) также будет связана по `this` с `obj1`. Лексическое связывание стрелочной функции не может быть переопределено (даже с `new`). Вероятно, самый распространенный сценарий использования — это обратные вызовы (например, при использовании обработчиков событий или таймеров):

```` js
function foo() {
 setTimeout(() => {
 // `this` здесь лексически наследуется от `foo()`
 console.log( this.a );
 },100);
}
var obj = { a: 2 };

foo.call( obj ); // 2
````

Хотя стрелочные функции предоставляют альтернативу для использования `bind(..)` с функциями для обеспечения нужного значения `this`, важно заметить, что по сути они блокируют традиционный механизм `this` в пользу более понятной лексической области видимости. До появления ES6 уже существовал довольно распространенный паттерн, который по духу был почти неотличим от стрелочных функций ES6:

```` js
function foo() {
 var self = this; // лексический захват `this`

 setTimeout( function(){

console.log( self.a );
 }, 100 );
}

var obj = { a: 2 };

foo.call( obj ); // 2
````

Хотя и `self = this`, и стрелочные функции могут показаться хорошими «решениями» для тех, кто не хочет использовать `bind(..)`, на самом деле это попытки сбежать от конструкции `this`, вместо того чтобы попытаться понять и принять ее.

## **Для чего нужно this?**

Следующий пример демонстрирует необходимость и пользу `this`:

```` js
function identify() {
 return this.name.toUpperCase();
}
function speak() {
 var greeting = "Hello, I’m " + identify.call( this );
 console.log( greeting );
}
var me = {
 name: "Kyle"
};
var you = {
 name: "Reader"
};
identify.call( me ); // KYLE
identify.call( you ); // READER
speak.call( me ); // Hello, I’m KYLE
speak.call( you ); // Hello, I’m READER
````

Этот фрагмент кода позволяет повторно использовать функции `identify()` и `speak()` для разных контекстных объектов (`me` и `you`), вместо того чтобы требовать создания отдельной версии функции для каждого объекта. Вместо того чтобы полагаться на `this`, можно было явно передать контекстный объект `identify()` и `speak()`:

```` js
function identify(context) {
 return context.name.toUpperCase();
}
function speak(context) {
 var greeting = "Hello, I'm " + identify( context );
 console.log( greeting );
}
identify( you ); // READER
speak( me ); // Hello, I’m KYLE
````

Тем не менее механизм `this` предоставляет более элегантный механизм неявной «передачи» ссылки на объект, что приводит к более ясной архитектуре API и простоте повторного использования. Чем сложнее ситуация, в которой вы используете это решение, тем четче видно, что передача контекста в явном параметре часто оказывается более громоздкой, чем передача контекста `this`. При более близком анализе объектов и прототипов можно увидеть, насколько удобно, когда коллекция функций может автоматически обращаться к подходящему контекстному объекту.

## **Счетчик вызова функции с использованием `this`**

```` js
function foo(num) {
 console.log( "foo: " + num );
 // Подсчет вызовов `foo`
 this.count++;
}

foo.count = 0;
var i;

for (i=0; i<10; i++) {
 if (i > 5) {
 foo( i );
 }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// сколько раз была вызвана функция `foo`?
console.log( foo.count ); // 0
````

Значение `foo.count` все равно остается равным 0, хотя четыре команды `console.log` четко показывают, что функция `foo(..)` была вызвана четыре раза. Недоразумение происходит от слишком буквальной интерпретации смысла `this` (в `this.count++`). Когда в коде выполняется команда `foo.count = 0`, она действительно добавляет свойство `count` к объекту функции `foo`. Но ссылка `this.count` внутри функции на самом деле указывает вовсе не на объект функции, так что даже несмотря на одинаковые имена свойств, корневые объекты различаются.

### **Решение задачи без использования `this` путём создания объекта для хранения свойства `count`:**

```` js
function foo(num) {
 console.log( "foo: " + num );
 // Подсчет вызовов `foo`
 data.count++;
}

var data = {
 count: 0
};

var i;

for (i=0; i<10; i++) {
 if (i > 5) {
 foo( i );
 }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// сколько раз была вызвана функция `foo`?
console.log( data.count ); // 4
````

Этот подход «решает» проблему, возвращается в зону комфорта более знакомого механизма - лексической области видимости.

### **Решение задачи без использования `this` путём использования идентификатора `foo` как ссылку на объект функции:**

```` js
function foo(num) {
 console.log( "foo: " + num );
 // Подсчет вызовов `foo`
 foo.count++;
}
foo.count = 0;
var i;
for (i=0; i<10; i++) {
 if (i > 5) {
 foo( i );
 }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// сколько раз была вызвана функция `foo`?
console.log( foo.count ); // 4
````

### **Решение задачи с использованием `this`:**

``` js
function foo(num) {
 console.log( "foo: " + num );
 // Подсчет вызовов `foo`.
 // Примечание: `this` в действительности сейчас содержит
 // `foo` из-за того, как была вызвана функция `foo`
 // (см. ниже)
 this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
 if (i > 5) {
 // используя `call(..)`, мы гарантируем, что `this` указывает на сам объект функции (`foo`)
 foo.call( foo, i );
 }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// сколько раз была вызвана функция `foo`?
console.log( foo.count ); // 4
````

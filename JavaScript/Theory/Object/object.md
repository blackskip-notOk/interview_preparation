# **Объекты**

## **Ссылки:**

* [**Дескрипторы свойст - Object.defineProperty()**](#дескрипторы-свойств)
* [**Создание объектов**](#создание-объектов)
* [**Объектные литералы**](#объектные-литералы)
* [**Расширенный синтаксис объектных литералов**](#расширенный-синтаксис-объектных-литералов)
* [**Создание объектов с помощью new**](#создание-объектов-с-помощью-операции-new)
* [**Object.create()**](#objectcreate)
* [**Запрашивание и установка свойств**](#запрашивание-и-установка-свойств)
* [`[[GET]]`](#get)
* [сеттер - `set`](#методы-получения-и-установки-свойств)
* [`[[Put]]`](#put)
* [**Объекты как ассоциативные массивы**](#объекты-как-ассоциативные-массивы)
* [**Ошибки доступа к свойствам**](#ошибки-доступа-к-свойствам)
* [**Неизменяемость**](#неизменяемость)
* [**Объектные константы**](#объектные-константы)
* [**Запрет расширения**](#запрет-расширения)
* [**Seal**](#seal)
* [**Freeze**](#freeze)
* [**Удаление свойств**](#удаление-свойств)
* [**Проверка свойств**](#проверка-свойств)
* [**Перечисление свойств**](#перечисление-свойств)
* [**Порядок перечисления свойств**](#порядок-перечисления-свойств)
* [**Поверхностное и глубокое копирование**](#поверхностное-и-глубокое-копирование)
* [**Сериализация объектов**](#сериализация-объектов)
* [**Методы получения и установки свойств**](#методы-получения-и-установки-свойств)
* [**Встроенные объекты**](#встроенные-объекты)

Объект — это составное значение: он агрегирует множество значений (эле­ментарные значения или другие объекты) и позволяет хранить и извлекать внутренние значения по имени. Объект представляет собой неупорядоченную коллекцию свойств каждое из которых имеет имя и значение. Помимо поддержки собственного набора свойств объект **JavaScript** также наследует свойства еще одного объекта, известного как его “прототип”. Методы объекта обычно представляют собой наследуемые свойства, и такое
наследование прототипов” считается ключевой возможностью **JavaScript**. Объекты **JavaScript** являются динамическими, т.к. свойства обычно можно Добавлять и удалять, но они могут использоваться для эмуляции статических объектов и “структур” из статически типизированных языков.
В **JavaScript** любое значение, отличающееся от строки, числа, значения `Symbol`, `true`, `false`, `null` или `undefined`, является объектом.
***

Имена свойств являются строками или значениями `Symbol`, а потому объекты отображают строки на значения. Такое сопоставление строк со зна­чениями называется по-разному: “хеш”, “хеш-таблица”, “словарь” или “ассоциатив­ный массив”. Никакой объект не может иметь два свойства с одним и тем же именем. Значением свойства может быть любое значение **JavaScript** либо функция получения или установки.

## **Дескрипторы свойств**

В дополнение к имени и значению каждое свойство имеет три атрибута свойства:

* атрибут `writable` (допускает запись) указывает, можно ли устанавливать значение свойства;

* атрибут `enumerable` (допускает перечисление) указывает, возвращается ли имя свойства в цикле `for/in`;

* атрибут `configurable` (допускает конфигурирование) указывает, можно ли удалять свойство и изменять его атрибуты.

До выхода ES5 язык **JavaScript** не давал возможности напрямую анализировать характеристики свойств на программном уровне, например, узнать, доступно свойство только для чтения или нет.

````js
var myObject = {
 a: 2
};

Object.getOwnPropertyDescriptor( myObject, "a" );
/** {
    value: 2,
    writable: true,
    enumerable: true,
    configurable: true
} */
````

Для добавления нового свойства или изменения существующего свойства (если оно допускает возможность настройки) с заданными характеристиками используется функция `Object.defineProperty()`:

````js
var myObject = {};

Object.defineProperty( myObject, "a", {
 value: 2,
 writable: true,
 configurable: true,
 enumerable: true
} );

myObject.a; // 2
````

Вызовом `defineProperty()` мы вручную добавляем простое, обычное свойство `a` к объекту `myObject`. Ручное добавление свойств используется только в том случае, если вы хотите изменить нормальное поведение одной из характеристик дескриптора.

* `writable: false` означает, что значение не может быть изменено, что отчасти эквивалентно определению пустой функции записи. Чтобы пустая функция записи полностью
соответствовала поведению `writable: false`, она должна при вызове выдавать ошибку `TypeError`.

* При попытке изменить определение дескриптора свойства, для которого запрещена настройка, итоговый вызов `defineProperty()` приводит к ошибке `TypeError` независимо от режима `strict`. Переключение `configurable` в состояние `false` необратимо. Следует помнить об одном нетривиальном исключении: даже если свойству уже присвоено `configurable: false`, характеристика `writable` всегда может быть переключена из `true`
в `false` без выдачи ошибки, но ее не удастся вернуть в `true`, если она уже находится в состоянии `false`. Также `configurable: false` блокирует возможность использования оператора `delete` для удаления существующего свойства.

* Если присвоить `enumerable` значение `false`, свойство не будет включаться в перечисления, хотя оно и остается полностью доступным.

***

## **Создание объектов**

Объекты можно создавать с помощью объектных литералов, ключевого сло­ва `new` и функции `Object.create()`:

### **Объектные литералы**

В своей простейшей форме объектный литерал представляет собой разделенный запятыми список пар имя:значение, заклю­ченный в фигурные скобки.

```` js
let empty = {};
let point = { x: 0, у: 1 };
let p2 = { x: point.x, y: point.y + 1 };
let book = {
    "main title": "JavaScript”,
    "sub-title": "The Definitive Guide",
    for: "all audiences",
    author: {
        firstname: "David",
        surname: "Flanagan"
        },
    };
````

Объектный литерал — это выражение, которое создает и инициализирует новый отдельный объект каждый раз, когда оно вычисляется. Значение каждого свойства вычисляется при каждом вычислении литерала. Таким образом, единс­твенный объектный литерал может создавать много новых объектов, если он находится внутри тела цикла или в функции, которая вызывается неоднократ­но, и значения свойств создаваемых объектов могут отличаться друг от друга.

#### **Расширенный синтаксис объектных литералов**

##### **Сокращенная запись свойств:**

````js
let х = 1, у = 2;
let о = { х, у };
о.х + о.у // => 3
````

##### **Вычисляемые имена свойств**

Иногда необходимо создать объект со специфическим свойством, но имя свойства не является константой стадии компиляции. Взамен имя нужного свойства хранится в переменной или возвращается вызовом какой-то функции. Для свойства тако­го вида применить базовый синтаксис объектных литералов не удастся. Вместо этого придется создать объект и затем добавить к нему желаемые свойства как дополнительный шаг:

````js
const PROPERTY_NAME = "pi";
function computePropertyName() { return "p" + 2; };
let о = {};
о[ PROPERTY__NAME ] = 1;
о[computePropertyName()] = 2;
````

Настроить объект подобного рода намного проще с помощью средства ES6, называемого вычисляемыми свойствамиу которое позволяет переместить квад­ратные скобки прямо внутрь объектного литерала:

````js
const PROPERTY__NAME = "pi";
function computePropertyName() { return "p" + 2 ; }
let p = {
[PROPERTY_NAME]: 1,
[computePropertyName()]: 2,
};
p.pl + p.p2 // => 3
````

Квадратные скобки в новом синтаксисе определяют границы произвольного вы­ражения **JavaScript**, которое вычисляется и результирующее значение (при необходи­мости преобразованное в строку) используется в качестве имени свойства.

Одна из ситуаций, когда могут понадобиться вычисляемые свойства, возни­кает при работе с библиотекой кода **JavaScript**, ожидающей предоставления объ­ектов с заданным набором свойств, имена которых определены как константы в этой библиотеке.

##### **Символы в качестве имен свойств**

Синтаксис вычисляемых свойств открывает доступ к еще одной очень важ­ной возможности объектных литералов. В ES6 и последующих версиях имена свойств могут быть строками или символами. Если вы присвоите символ пере­менной или константе, то сможете использовать этот символ как имя свойства с применением синтаксиса вычисляемых свойств:

````js
const extension = Symbol ("my extension symbol");
let о = {
[extension] : { /* в этом объекте хранятся данные расширения */ }
};
о[extension].х = 0; // Это не будет конфликтовать с остальными свойствами о
````

Каждое значение `Symbol` отличается от любого другого значения `Symbol`, т.е. символы хороши для создания уни­кальных имен свойств. Смысл значений `Symbol` связан не с защитой, а с определением безопасного механизма расширения для объектов **JavaScript**.

##### **Операция распространения**

Синтаксис `...` часто называется операцией распространения, но он не является подлинной
операцией **JavaScript** в каком-либо смысле. Это синтаксис особого случая, до­ступный только внутри объектных литералов. (В других контекстах **JavaScript**
многоточие применяется для других целей, но объектные литералы — единс­твенный контекст, где многоточие вызывает такую вставку одного объекта в другой объект.). Если и распространяемый объект, и объект, куда он распространяется, име­ют свойство с тем же самым именем, тогда значением такого свойства будет то, которое поступит последним.
Операция распространения распространяет только собственные свойства объекта, но не унаследованные. Хотя операция распространения пред­ставлена всего лишь тремя точками в коде, она способна загрузить интерпре­татор **JavaScript** значительным объемом работы. Если объект имеет n свойств, то процесс их распространения в другой объект, вероятно, окажется операцией О(n). Таким образом, когда вы используете `...` внутри цикла или рекурсивной функции в качестве способа сбора данных в одном крупном объекте, то можете
написать неэффективный алгоритм `O(n**2)` который будет плохо масштабиро­ваться с увеличением n.

##### **Сокращенная запись методов**

В ES6 синтаксис объектных литералов (и также синтаксис оп­ределения классов) был расширен, чтобы сделать возможным сокращение, где ключевое слово `function` и двоеточие опускаются:

````js
let square = {
area() { return this.side * this.side; ),
side: 10
};

square.area() // => 100
````

Сокращенный синтаксис делает яснее тот факт, что `area()` является методом, а не свойством с данными вроде `side`. Используя сокращенный синтаксис, имя свой­ства может принимать любую форму, допустимую в объектном литерале:

````js
const METHOD_NAME = V;

const symbol = Symbol();

let weirdMethods = {
"method With Spaces"(x) { return x + 1; },
[METHOD_NAME](x) { return x + 2; },
[symbol](x) { return x + 3; }
};

weirdMethods ['method With Spaces'](1) // => 2
weirdMethods[METHOD_NAME](1) // => 3
weirdMethods[symbol](1) // => 4
````

Использование значения Symbol в качестве имени метода не настолько странно, как кажется. Чтобы сделать объект итерируемым (что позволит его применять с циклом `for/of`), вы обязаны определить метод с символьным име­нем `Symbol.iterator`.
***

### **Создание объектов с помощью операции `new`**

Операция `new` создает и инициализирует новый объект. За ключевым словом `new` должен следовать вызов функции. Применяемая подобным способом фун­кция называется конструктором и предназначена для инициализации вновь созданного объекта. В **JavaScript** предусмотрены конструкторы для встроенных типов:

```` js
let о = new Object (); // Создает пустой объект: то же, что и {}
let а = new Array (); // Создает пустой массив: то же, что и []
let d = new Date() ; // Создает объект Date, представляющий текущее время
let г = new Мар (); // Создает объект Мар для отображения ключ/значение
````

В дополнение к таким встроенным конструкторам общепринято определять собственные функции конструкторов для инициализации создаваемых новых объектов.
***

### **`Object.create()`**

`Object.create()` создает новый объект, используя в качестве его [прототи­па](./Prototype/prototype.md) первый аргумент:

```` js
let ol = Object .create ({х : 1, у: 2});// о1 наследует свойства х и у.
ol.x + ol.y // => 3
````

Можно передать `null`, чтобы создать новый объект, не имеющий про­тотипа, но в таком случае вновь созданный объект ничего не унаследует, даже базовые методы вроде `to String()`.

`Object.create()` также принимает необяза­тельный второй аргумент, который описывает свойства нового объекта.

Один из случаев использования `Object.create()` — когда вы хотите за­щититься от непреднамеренной (но не злоумышленной) модификации объекта библиотечной функцией, над которой вы не имеете контроля. Вместо переда­чи объекта напрямую функции вы можете передать объект, унаследованный от него. Если функция читает свойства этого объекта, то она будет видеть унасле­дованные значения. Однако если она устанавливает свойства, то запись не будет влиять на первоначальный объект.

````js
let о = { х: "не изменяйте это значение” };
library.function(Object.create (о)); //Защита от случайной модификации
````

***

## **Запрашивание и установка свойств**

Чтобы получить значение свойства, применяйте точку `.` или `[ ]`. В левой стороне должно быть выраже­ние, значением которого является объект. Если используется точка, тогда с пра
вой стороны должен находиться простой идентификатор, именующий свойство. В случае применения квадратных скобок значение внутри скобок должно быть выражением, вычисляемым в строку, которая содержит имя желаемого свойства:

```` js
let author = book.author; //Получить свойство "author” объекта book
let паше = author.surname; //Получить свойство "surname” объекта author
let title = book["main title"]; // Получить свойство "main title" объекта book
````

Для создания набора свойств используйте точку или квадратные скобки, но в левой стороне выражения присваи­вания:

````js
book.edition = 7; // Создать свойство "edition" объекта book
book ["main title"] = "ECMAScript"; // Изменить свойство "main title"
````

Когда применяется запись с квадратными скобками выра­жение внутри квадратных скобок должно вычисляться в строку или значение, кото­рое может быть преобразовано в строку или значение Symbol.

### **`[[Get]]`**

В механизме обращения к свойствам существует неочевидный, но важный нюанс.

````js
var myObject = {
 a: 2
};

myObject.a; // 2
````

`myObject.a` — обращение к свойству, но оно не ограничивается простым поиском свойства с именем `a` в объекте `myObject`, как могло бы показаться. Согласно спецификации, этот фрагмент выполняет операцию `[[Get]]` (нечто вроде вызова функции: `[[Get]]()`) для `myObject`. Встроенная операция по умолчанию `[[Get]]` у объекта сначала ищет в объекте свойство с указанным именем, и если оно будет найдено — возвращает соответствующее значение. При этом алгоритм `[[Get]]` определяет другие важные аспекты поведения, если ему не удается найти свойство с указанным именем. При этом происходит [обход цепочки](./Prototype/prototype.md) `[[Prototype]]`. У операции `[[Get]]` есть одна важная особенность: если ей не удается каким-либо образом получить значение запрашиваемого
свойства, она вместо этого возвращает значение `undefined`:

```` js
var myObject = {
 a: 2
};

myObject.b; // undefined
````

### **`[[Put]]`**

Поведение `[[Put]]` при вызове зависит от ряда факторов, в том числе (и прежде всего) от того, существует ли свойство в объекте или нет.
Если свойство присутствует, алгоритм `[[Put]]` в общих чертах проверяет следующее:

1. Является ли свойство дескриптором функции доступа? В таком случае вызывается set-функция, если она существует.

2. Свойство является дескриптором данных с характеристикой `writable: false`? В таком случае при отсутствии режима `strict` происходит незаметный сбой, а в режиме `strict` выдается ошибка `TypeError`.

3. В остальных случаях значение присваивается существующему свойству, как обычно.

Если свойство отсутствует в объекте, операция `[[Put]]` становится еще более сложной и неочевидной.

***

## **Объекты как ассоциативные массивы**

Синтаксис с квадратными скобками и строкой выглядит как доступ в массив, но индексированный не по числам, а по строкам. Такой вид массива известен как ассоциативный массив (а также хеш, отображение или словарь). Объекты **JavaScript** являются ассоциативными массивами.

В С, C++, Java и похожих строго типизированных языках объект может иметь только фиксированное количество свойств, а имена свойств должны быть определены заранее. Поскольку **JavaScript** — слабо типизированный язык, такое правило не применяется: программа способна создавать любое количес­тво свойств в любом объекте. Тем не менее, при использовании операции `.` для доступа к свойству объекта имя свойства выражается как идентификатор. Идентификаторы в программе **JavaScript** должны набираться буквально; они не относятся к типам данных, а потому ими нельзя манипулировать в программе.
С другой стороны, когда вы обращаетесь к свойству объекта с помощью за­писи в форме массива `[]`, имя свойства выражается в виде строки. Строки яв­ляются типом данных **JavaScript**, так что их можно создавать и манипулировать ими во время выполнения программы.

```` js
let addr = "";
for (let i = 0; i < 4; i++) {
addr += customer[`address${i}`] + "\n";
}
````

С объектами **JavaScript** обычно взаимодействуют как с ассоциативными мас­сивами. Тем не менее, в ES6 и последующих версиях класс `Мар`, часто оказывается более удачным вариантом, нежели создание простого объекта.
***

## **Ошибки доступа к свойствам**

Выражения доступа к свойствам не всегда возвращают или устанавливают значение. Запрашивание свойства, которое не су­ществует, не считается ошибкой. Если свойство `х` не найдено как собственное или унаследованное свойство объекта `о`, то вычисление выражения доступа к свойству `о.х` дает значение `undefined`. Тем не менее, попытка запрашивания свойства объекта, который не существу­ет, является ошибкой. Значения `null` и `undefined` не имеют свойств, и запраши­вание свойств таких значений будет ошибкой. `let len = book.subtitle.length; // ITypeError: undefined не имеет свойства length`.
Выражения доступа к свойствам терпят неудачу, если с левой стороны опе­рации `.` находится `null` или `undefined`. Защититься от возникновения проблемы такого рода можно двумя способами:

````js
// Многословная и явная методика
let surname = undefined;
if (book) {
if (book.author) {
surname = book.author.surname;
};

// Лаконичная и идиоматическая альтернатива для получения surname либо null или undefined
surname = book && book.author && book.author.surname;

/** условный до­ступ к свойствам с помощью ?. позволяет переписать предыдущее выра­жение присваивания следующим образом:*/
let surname = book?.author?.surname;
````

Попытка установки свойства для `null` или `undefined` также генерирует `ТуреЕггог`. Попытки установки свойств для остальных значений тоже не всег­да оказываются успешными: некоторые свойства допускают только чтение и не могут быть установлены, а некоторые объекты не разрешают добавление новых свойств. В строгом режиме исключение `ТуреЕггог` генери­руется всякий раз, когда попытка установки свойства терпит неудачу. За рамка­ми строгого режима такие неудачи обычно проходят молча.

Попытка установки свойства `р` объекта `о` терпит неудачу в следующих обстоятельствах.

* `о` имеет собственное свойство `р`, допускающее только чтение: устанавли­вать свойства только для чтения невозможно.

* `о` имеет унаследованное свойство `р`, допускающее только чтение: скрывать унаследованное свойство только для чтения собственным свойством с таким же именем невозможно.

* `о` не имеет собственного свойства `р`; `о` не наследует свойство `р` с методом установки и атрибут `extensible` объекта `о` равен `false`. Поскольку `р` не существует в `о` и метод установки отсутствует, то свойство `р` должно быть добавлено к `о`. Но если объект `о` не допускает расширения, тогда в нем нельзя определять новые свойства.

***

## **Неизменяемость**

Иногда требуется создать свойства или объекты, которые не могут изменяться (случайно или намеренно). В ES5 была добавлена поддержка, позволяющая сделать это несколькими разными способами. Важно заметить, что все эти способы создают поверхностную неизменяемость. Иначе говоря, они влияют только на объект и на его непосредственные характеристики свойств. Если объект содержит ссылку на другой объект, содержимое этого объекта остается изменяемым:

````js
myImmutableObject.foo; // [1,2,3]
myImmutableObject.foo.push( 4 );
myImmutableObject.foo; // [1,2,3,4]
````

В этом фрагменте предполагается, что объект `myImmutableObject` уже создан и защищен как неизменяемый. Но чтобы также защитить содержимое `myImmutableObject.foo` (который сам является объектом — массивом), вы должны сделать неизменяемым `foo` одним или несколькими способами:

### **Объектные константы**

Объединяя `writable: false` с `configurable: false`, можно фактически создать константу (с невозможностью изменения, переопределения или удаления) как свойство объекта:

````js
var myObject = {};

Object.defineProperty( myObject, "FAVORITE_NUMBER", {
 value: 42,
 writable: false,
 configurable: false
} );
````

### **Запрет расширения**

Если вы хотите запретить возможность добавления новых свойств в объект, но оставить остальные свойства объекта без изменений, вызовите `Object.preventExtensions()`:

````js
var myObject = {
 a: 2
};

Object.preventExtensions( myObject );

myObject.b = 3;
myObject.b; // undefined
````

Если не действует режим `strict`, попытка создания `b` завершается неудачей без выдачи ошибки. В режиме `strict` выдается ошибка `TypeError`.

### **Seal**

`Object.seal()` создает «запечатанный» объект; функция получает существующий объект и фактически вызывает для него `Object.preventExtensions()`, но также все существующие свойства получают пометку `configurable: false`. Таким образом, к объекту не только нельзя добавлять новые свойства, но и также нельзя изменять конфигурацию или удалять существующие свойства (хотя вы можете изменять их значения).

### **Freeze**

`Object.freeze()` создает «замороженный» объект; функция получает существующий объект и фактически вызывает для него `Object.seal()`, но также все свойства доступа к данным получают пометку `writable: false`, так что их значения не могут быть изменены. Это самая высокая степень неизменяемости, которая может быть достигнута для самого объекта; она предотвращает любые изменения объекта или его непосредственных свойств (хотя, как упоминалось выше, не влияет на содержимое других объектов, на которые указывают ссылки).

Объект также можно отправить в «глубокую заморозку» — вызовите `Object.freeze()` для объекта, а затем рекурсивно переберите все объекты, на которые он ссылается (и которые до настоящего момента не изменялись), и вызовите `Object.freeze()` для этих объектов.

## **Удаление свойств**

Операция `delete` удаляет свойство из объекта. Ее единственным операндом должно быть выражение доступа к свойству. `delete` работает не со значением свойства, а с самим свойством:

````js
delete book.author; // Объект book теперь не имеет свойства author
delete book[,fmain title"]; // А теперь он не имеет и свойства "main title"
````

Операция `delete` удаляет только собственные свойства, но не унаследован­ные. (Чтобы удалить унаследованное свойство, нужно удалять его из объекта-прототипа, где оно определено. Такое действие повлияет на каждый объект, унаследованный от этого прототипа.)

Выражение `delete` вычисляется как `true`, если удаление прошло успешно, было безрезультатным или когда применяется с выражением, не являющимся выражением доступа к свойству:

````js
let о = {х: l}; // о имеет собственное свойство х и наследует свойство toString
delete о.х // => true: свойство х удаляется
delete о.х // => true: ничего не делает (х не существует), но в любом случае true
delete o.toString // => true: ничего не делает (toString - не собственное свойство)
delete 1 // => true: бессмысленно, но в любом случае true
````

Операция `delete` не удаляет свойства, которые имеют атрибут `configurable`, установленный в `false`. Некоторые свойства встроенных объектов не подде­рживают конфигурирование, т.к. представляют собой свойства глобального объекта, созданного объявлениями переменных и функций. В строгом режиме попытка удаления свойства, не допускающего конфигурирование, приводит к генерации `ТуреЕггог`. В нестрогом режиме `delete` в таком случае просто вы­числяется как `false`. При удалении конфигурируемых свойств глобального объекта в нестрогом режиме вы можете опускать ссылку на глобальный объект и указывать после операции `delete` имя свойства:

```` js
globalThis.x = 1 ; // Создать конфигурируемое свойство глобального объекта (никаких let или var)
delete х // => true: это свойство можно удалить
````

Однако в строгом режиме операция `delete` генерирует `SyntaxError`, если ее операндом оказывается неуточненный идентификатор вроде `х`, и вы должны обеспечить явный доступ к свойству:

````js
delete х; // SyntaxError в строгом режиме
delete globalThis.x; // Это работает
````

***

## **Проверка свойств**

Объекты **JavaScript** можно рассматривать как наборы свойств и зачастую полезно иметь возможность проверять членство свойства в таком наборе — с целью выяснения, имеет ли объект свойство с заданным именем. Это дела­ется с помощью операции `in` , посредством методов `hasOwnProperty()` и `propertyIsEnumerable()` или просто путем запрашивания свойства.

* Операция `in` ожидает с левой стороны имя свойства и с правой стороны объект. Она возвращает `true`, если объект имеет собственное или унаследован­ное свойство с указанным именем.

* Метод `hasOwnProperty()` объекта проверяет, имеет ли данный объект собственное свойство с заданным именем. Для унаследованных свойств он воз­вращает `false`.

* Метод `propertyIsEnumerable()` улучшает проверку `hasOwnProperty()`. Он возвращает `true`, только если именованное свойство является собственным и атрибут `enumerable` имеет значение `true`.

Вместо использования операции `in` часто достаточно просто запросить свойство и применить `!==` для его проверки на предмет `undefined`. Операция `in` проводит различие между свойст­вами, которые не существуют, и свойствами, которые существуют, но были ус­тановлены в `undefined`.

````js
let о = { х: undefined }; // Свойство явно устанавливается в undefined
о.х !== undefined // => false: свойство существует, но равно undefined
о.у !== undefined // => false: свойство не существует
'х' in о // => true: свойство существует
'у' in о // => false: свойство не существует
delete о.х; // Удаление свойства х
'х' in о // -> false: свойство больше не существует
````

***

## **Перечисление свойств**

Цикл `for/in` выполняет тело цикла по одному разу для каждого перечислимого свойства (собственного или унасле­дованного) указанного объекта, присваивая имя свойства переменной цикла. Встроенные методы, наследуемые объектами, не являются перечислимыми.

Чтобы избежать перечисления унаследованных свойств посредством `for/in`, вы можете поместить внутрь тела цикла явную проверку:

````js
for (let р in о) {
if (o.hasOwnProperty(р)) continue; // Пропускать унаследованные свойства
}

for (let р in о) {
if (typeof о[р] === 'function') continue; // Пропускать все методы
}
````

В качестве альтернативы использованию цикла `for/in` часто легче получить массив имен свойств для объекта и затем проходить по этому массиву в цикле `for/of`.
Есть четыре функции, которые можно применять для получения мас­сива имен свойств:

1. Функция `Object.keys()` возвращает массив имен перечислимых собс­твенных свойств объекта. Она не включает не перечислимые свойства, унаследованные свойства или свойства с именами, представленными пос­редством значений `Symbol`.

2. Функция `Object.getOwnPropertyNames()` работает подобно `Object.keys()`, но возвращает массив также имен не перечислимых собственных свойств при условии, что их имена представлены строками.

3. Функция `Object.getOwnPropertySymbols()` возвращает собственные свойства, имена которых являются значениями `Symbol`, перечислимые они или нет.

4. Функция `Reflect.ownKeys()` возвращает имена всех собственных свойств, перечислимых и не перечислимых, представленных как строками, так и значениями `Symbol`.

***

### **Порядок перечисления свойств**

В ES6 формально определен порядок, в котором перечисляются собственные свойства объекта. `Object.keys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()`, `Reflect.ownKeys()` и связанные мето­ды, такие как `JSON.stringify()`, перечисляют свойства в следующем поряд­ке:

* Строковые свойства, имена которых являются неотрицательными целыми числами, перечисляются первыми в числовом порядке от меньших к боль­шим. Это правило означает, что свойства массивов и подобных им объек­тов будут перечисляться по порядку.

* После того, как перечислены все свойства, которые выглядят похожими на индексы массива, перечисляются все оставшиеся свойства со строковыми именами (включая свойства, которые выглядят как отрицательные числа или числа с плавающей точкой). Такие свойства перечисляются в порядке, в котором они добавлялись к объекту. Для свойств, определенных в объ­ектном литерале, этим порядком будет порядок их следования в литерале.

* Наконец, свойства с именами, представленными с помощью значений `Symbol`, перечисляются в порядке, в котором они добавлялись к объекту.

Порядок перечисления для цикла `for/in` определен не настолько строго, но разные реализации перечис­ляют собственные свойства в только что описанном порядке, после чего пере­мещаются вверх по цепочке прототипов, перечисляя свойства в том же порядке для каждого объекта-прототипа. Тем не менее, свойство не будет перечисляться, если свойство с тем же самым именем уже подвергалось перечислению или даже когда уже просматривалось не перечислимое свойство с таким же именем.
***

## **Расширение объектов**

### **Поверхностное и глубокое копирование**

````js
function anotherFunction() { /*..*/ }

var anotherObject = {
 c: true
};

var anotherArray = [];

var myObject = {
 a: 2,
 b: anotherObject, // ссылка, а не копия!
 c: anotherArray, // другая ссылка!
 d: anotherFunction
};

anotherArray.push( anotherObject, myObject );
````

У поверхностной копии значение `a` нового объекта будет копией значения `2`, но свойства `b`, `c` и `d` будут всего лишь ссылками на те же области памяти, на которые указывают ссылки исходного объекта. Глубокое копирование создаст копии не только `myObject`, но и `anotherObject` и `anotherArray`. Но тогда возникает проблема: `anotherArray` содержит ссылки на `anotherObject` и `myObject`, так не нужно ли продублировать и их, вместо того
чтобы ограничиться сохранением ссылок? Существование циклических ссылок приводит к проблеме бесконечного циклического дублирования объектов. Нужно ли обнаружить циклическую ссылку и просто разбить циклический обход ссылок (оставляя глубокий элемент не полностью продублированным)? Выдать сообщение об ошибке? Выбрать некий промежуточный вариант? Более того, не очень понятно, что должно считаться «дублированием» функции. Существуют разные трюки вроде извлечения сериализованного представления `toString()` исходного кода функции (который меняется в зависимости от реализации, и даже для разных ядер в зависимости от типа функции).
Разные фреймворки **JS** выбирают собственные интерпретации и принимают свои собственные решения. Одно подмножество решений основано на том, что JSON-безопасные объекты (то есть объекты, которые могут быть [сериализованы в строку JSON](#сериализация-объектов), которая затем разбирается в объект с той же структурой и значениями) легко дублируются следующим образом:

````js
var newObj = JSON.parse(JSON.stringify( someObj ));
````

Конечно, для этого необходимо убедиться в JSON-безопасности объекта. В одних ситуациях это делается тривиально, в других нет.

В то же время поверхностное копирование вполне понятно и создает меньше проблем, поэтому в ES6 для этой задачи была определена функция `Object.assign()`.
Функция `Object.assign()` ожидает получения в своих аргументах двух и более объектов. Она модифицирует и возвращает первый аргумент, в котором указан целевой объект, но не изменяет второй и любой последующий аргу­мент, где указаны исходные объекты. Для каждого исходного объекта функция `Object.assign()` копирует его перечислимые собственные  свойства (включая те, имена которых являются значениями `Symbol`) в целевой объект (посредством обычного присваивания =). Она обраба­тывает исходные объекты в порядке их следования в списке аргументов, так что свойства первого исходного объекта переопределяют свойства с такими же име­
нами в целевом объекте, а свойства второго исходного объекта (если он указан) переопределяют свойства с такими же именами в первом исходном объекте. Функция `Object.assign()` копирует свойства с помощью обычных операций получения и установки свойств, поэтому если исходный объект располага­ет методом получения или целевой объект имеет метод установки, то они будут вызваны во время копирования, но сами не скопируются.

Одна из причин передачи свойств из одного объекта другому — когда име­ется объект, который определяет стандартные значения для множества свойств, и необходимо скопировать такие стандартные свойства в другой объект, если свойства с теми же самыми именами в нем пока не существуют. `Object.assign(о, defaults); // Переопределяет все в о стандартными свойствами`. Взамен вы можете создать новый объект, скопировать в него стандартные свойства и затем переопределить их посредством свойств в `о`: `о = Object.assign({}, defaults, о);` Копирова­ть и переопределять свойства можно также с использованием операции распростра­нения `...`, `о = {...defaults, ...0 };`.

***

## **Сериализация объектов**

Сериализация объектов представляет собой процесс преобразования состоя­ния объекта в строку, из которой позже он может быть восстановлен. Функции `JSON.stringify()` и `JSON.parse()` сериализируют и восстанавливают объек­ты **JavaScript**. Эти функции работают с форматом обмена данными **JSON**, кото­рый означает “JavaScript Object Notation” и имеет синтаксис, очень похожий на синтаксис литералов объектов и массивов. Синтаксис **JSON** является подмножеством синтаксиса **JavaScript** и не спо­собен представлять все значения **JavaScript**. Поддерживается возможность се­риализации и восстановления объектов, массивов, строк, конечных чисел, `true`, `false` и `null`. Значения `NaN`, `Infinity` и `-Infinity` сериализируются в `null`. Объекты `Date` сериализируются в строки дат формата ISO, но `JSON.parse()` оставляет их в строковой форме и не восстанавливает первоначальные объекты `Date`. Объекты `Function`, `RegExp` и `Error` и значение `undefined` не могут сериализироваться или восстанав­ливаться. `JSON.stringify()` сериализирует только перечислимые собствен­ные свойства объекта. Если значение свойства не может быть сериализировано, тогда такое свойство просто опускается из строкового вывода. Функции `JSON.stringify()` и `JSON.parse()` принимают необязательный второй аргу­мент, который можно применять для настройки процесса сериализации и/или восстановления, указывая список свойств, подлежащих сериализации или преобразуя определенные значения во время процесса сериализации.
***

## **Методы получения и установки свойств**

В ES5 появилась возможность переопределения некоторых операций по умолчанию не на уровне объектов, а на уровне отдельных свойств; для этой цели используются `get-` (геттеры) и `set-` методы (сеттеры). Геттер — свойства, которые вызывают скрытую функцию для получения нужного значения. Сеттер — свойства, которые вызывают скрытую функцию для присваивания значения.
Когда вы определяете для свойства геттер и/или сеттер, его определение становится «дескриптором методов доступа» (в отличие от «дескриптора данных»). Для дескрипторов методов доступа характеристики `value` и `writable` дескриптора считаются несущественными и игнорируются, а **JS** учитывает только характеристики `set` и `get` свойства (а также `configurable` и `enumerable`).

````js
var myObject = {
 // define a getter for `a`
 get a() {
 return 2;
 }
};

Object.defineProperty(
 myObject, // приемник
 "b", // имя свойства
 { // дескриптор определение геттера для `b`
 get: function() { return this.a * 2 },
 // чтобы свойство `b` включалось в список свойств объекта
 enumerable: true
 }
);

myObject.a; // 2
myObject.b; // 4
````

При использовании синтаксиса объектных литералов как с `get a() { .. }`, так и с явным определением `defineProperty()`, в обоих случаях будет создано свойство объекта, которое на самом деле не содержит значения. Тем не менее при обращении к этому свойству автоматически вызывается скрытая функция для геттера, и возвращенное этой функцией значение становится результатом обращения к свойству:

````js
var myObject = {
 // определение геттера для `a`
 get a() {
 return 2;
 }
};

myObject.a = 3;
myObject.a; // 2
````

Так как для `a` определен только геттер, при попытке задать значение `a` операция не выдаст ошибку, а просто игнорирует присваивание. Даже если бы существовал действительный сеттер, наш специализированный геттер запрограммирован так, что он возвращает только `2`, так что попытка присваивания ни к чему не приведет. Чтобы ситуация выглядела более разумно, свойства также могут определяться с сеттерами, переопределяющими операцию `[[Put]]` по умолчанию (то есть присваивание) на уровне отдельных свойств. Почти всегда следует объявлять как геттер, так и сеттер (определение только одного метода доступа часто приводит к неожиданному и нелогичному поведению). Свойства с методами доступа можно определять посредством [расширения синтаксиса объектных литералов](#расширенный-синтаксис-объектных-литералов):

````js
var myObject = {
 // определить геттер для `a`
 get a() {
 return this._a_;
 },
 // определить сеттер для `a`
 set a(val) {
 this._a_ = val * 2;
 }
};
myObject.a = 2;
myObject.a; // 4
````

В этом примере заданное для присваивания значение `2` (операция `[[Put]]`) сохраняется в другой переменной `_a_`. Имя `_a_` выбрано в данном примере исключительно по общепринятой схеме; оно не несет никакой информации о поведении — это обычное свойство, как и любое другое.

Если свойство имеет метод получения и метод установки, то оно является свойством для чтения/записи. При наличии только метода получения свойство поддерживает только чтение. А если свойство располагает только методом уста­новки, тогда оно считается свойством только для записи (в свойствах с данны­ми подобное невозможно), и попытки его чтения всегда дают `undefined`.

Применение свойств с методами доступа включают контроль корректности при
записи свойств и возвращение отличающихся значений при чтении каждого свойства:

````js
// Этот объект генерирует строго увеличивающиеся порядковые номера
const serialnum = {
// Свойство с данными, которое хранит следующий порядковый номер.
// Символ _ в имени свойства подсказывает, что оно предназначено
// только для внутреннего использования,
_n : О,
// Возвратить текущее значение и инкрементировать его
get next() { return this._n++; },
// Установить новое значение п, но только если оно больше текущего
set next(n) {
    if (n > this._n) this._n = n;
    else throw new Error ("порядковый номер можно устанавливать только в большее значение");
    }
};

serialnum.next = 10; // Установить начальный порядковый номер

serialnum.next // => 10

serialnum.next // => 11: при каждом обращении к next мы получаем отличающееся значение
````

Наконец, ниже приведен еще один пример использования метода получения для реализации свойства с “магическим” поведением:

````js
/** Этот объект имеет свойства с методами доступа, которые возвращают случайные числа.
Скажем, каждое вычисление выражения random.octet в результате дает случайное число между 0 и 255. */
const random = {
get octet() { return Math.floor(Math.random() * 256); },
get uint16() { return Math.floor (Math.random() * 65536); },
get int16() { return Math.floor(Math.random() * 65536) -32768; }
};
````

***

## **Встроенные объекты**

Также существует несколько других подтипов, обычно называемых встроенными объектами:

1. String
2. Number
3. Boolean
4. Object
5. Function
6. Array
7. Date
8. RegExp
9. Error
Встроенные объекты выглядят как обычные типы и даже классы, если опираться на их сходство с другими языками. Но в **JS** они в действительности представляют собой встроенные функции. Каждая из встроенных функций может использоваться как конструктор (то есть вызов функции с оператором `new`), результатом вызова которого является создание объекта заданного подтипа.

```` js
var strPrimitive = "I am a string";
typeof strPrimitive; // "string"
strPrimitive instanceof String; // false

var strObject = new String( "I am a string" );
typeof strObject; // "object"
strObject instanceof String; // true
// проверка подтипа объекта
Object.prototype.toString.call( strObject ); // [object String]
````

У `null` и `undefined` не существует объектных оберток, только примитивные значения. С другой стороны, значения `Date` могут создаваться только в сконструированной форме, у них нет аналогичной литеральной формы.
Объекты `Object`, массивы `Array`, функции `Function` и регулярные выражения `RegExp` — все они являются объектами независимо от того, используется ли для них литеральная или сконструированная форма. В некоторых ситуациях сконструированная форма предоставляет большую гибкость при создании объекта, чем аналогичная литеральная форма. Так как объекты могут создаваться любым из двух способов, более простая литеральная форма почти повсеместно считается предпочтительной. Сконструированная форма используется только в тех случаях, когда вам необходимы расширенные возможности.
Объекты `Error`  редко создаются в коде явно; обычно они создаются автоматически при выдаче исключений. Они могут создаваться в сконструированной форме `new Error(..)`, но такая необходимость возникает редко.

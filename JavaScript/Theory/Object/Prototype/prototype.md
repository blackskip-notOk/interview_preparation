# **Прототипы `[[Prototype]]`**

У объектов **JavaScript** имеется внутреннее свойство, обозначенное в спецификации `[[Prototype]]`. В нем хранится обычная ссылка на другой объект. Почти у всех объектов в момент их создания этому свойству присваивается значение, отличное от `null`.

## **Для чего нужна ссылка `[[Prototype]]`?**

При выполнении операции [GET](../object.md) (например при вызове `myObj.a`) по умолчанию прежде всего проверяется, содержит ли сам объект свойство `a`, и если содержит — то оно используется. Если операция `[[Get]]` по умолчанию не может найти запрашиваемое свойство непосредственно в объекте, она переходит по ссылке `[[Prototype]]` объекта:

````js
var anotherObject = {
 a: 2
};
// создать объект, связанный с `anotherObject`
var myObject = Object.create( anotherObject );
myObject.a; // 2
````

Очевидно, свойство `myObject.a` не существует; тем не менее обращение к свойству завершается успешно (оно обнаруживается в `anotherObject`) и возвращает значение `2`. Но если бы свойство `a` не было обнаружено и в `anotherObject`, то была бы проверена и его цепочка `[[Prototype]]`, если она не пуста, и поиск перешел бы по ней. Этот процесс продолжается до тех пор, пока не будет найдено подходящее имя свойства или не завершится цепочка `[[Prototype]]`. Если к концу цепочки подходящее свойство так и не будет найдено, операция `[[Get]]` возвращает `undefined`.
По аналогии с описанным процессом поиска по цепочке `[[Prototype]]`, если вы перебираете содержимое объекта в цикле `for..in`, в перечисление будут включены все свойства, достижимые по цепочке (и для которых разрешено перечисление). Если оператор `in` используется для проверки существования свойства объекта, он проверит всю цепочку объекта (независимо от перечисляемости).
Итак, цепочка `[[Prototype]]` проверяется по одному звену при выполнении различных операций поиска. Поиск останавливается при обнаружении свойства или завершении цепочки.
***

## **Object.prototype**

Любая нормальная цепочка `[[Prototype]]` завершается на встроенном объекте `Object.prototype`. Этот объект включает разнообразные стандартные возможности, используемые в **JS**, потому что все нормальные (встроенные, не являющиеся расширениями управляющей среды) объекты **JavaScript** «происходят» от объекта `Object.prototype` (то есть этот объект находится на вершине их цепочки `[[Prototype]]`).

### **Назначение и замещение свойств**

`myObject.foo = "bar"`

Если объект `myObject` уже содержит нормальное свойство доступа к данным с именем `foo` (то есть свойство находится непосредственно в объекте), присваивание ограничивается простым изменением значения существующего свойства. Если `foo` не присутствует непосредственно в `myObject`, происходит обход цепочки `[[Prototype]]`, как при операции `[[Get]]`. Если `foo` не удается найти нигде в цепочке, свойство `foo` добавляется прямо в `myObject` с заданным значением, как и следовало ожидать. Если имя свойства `foo` встречается как в самом объекте `myObject`, так и на более высоком уровне цепочки `[[Prototype]]`, начинающейся с `myObject`, это называется замещением (**shadowing**). Свойство `foo` непосредственно в `myObject` замещает любое свойство `foo`, находящееся выше в цепочке, потому что поиск `myObject.foo` всегда находит свойство `foo` на самом нижнем уровне цепочки.

Три возможные ситуации с присваиванием `myObject.foo = "bar"`, когда `foo` находится не в `myObject`, а на более высоком уровне цепочки `[[Prototype]]`:

1. Если выше в цепочке `[[Prototype]]` находится нормальное свойство доступа к данным с именем `foo` и оно не помечено как доступное только для чтения (`writable: true`), то новое свойство с именем `foo` добавляется прямо в `myObject`, что приводит к замещению существующего свойства.

2. Если свойство `foo` находится выше в цепочке `[[Prototype]]` и оно помечено как доступное только для чтения (`writable: false`), то запрещаются как назначение существующего свойства, так и создание замещенного свойства. Если код выполня
ется в режиме `strict`, происходит ошибка, а если нет — присваивание значения свойства игнорируется. В любом случае замещение не происходит.

3. Если свойство `foo` находится выше в цепочке `[[Prototype]]` и оно имеет [сеттер](../object.md), то всегда будет вызываться сеттер. Свойство `foo` не будет добавлено в `myObject` (с замещением), и сеттер `foo` не будет переопределяться.

Многие разработчики считают, что присваивание свойству (`[[Put]]`) всегда приводит к замещению, если свойство уже существует выше в цепочке `[[Prototype]]`, но, как видите, это справедливо только в одной из трех описанных ситуаций. Чтобы заместить `foo` в случаях 2 и 3, вы не сможете использовать присваивание `=`. Вместо этого необходимо использовать [`Object.defineProperty(..)`](../object.md) для добавления `foo` к `myObject`. Присутствие свойства, доступного только для чтения, блокирует неявное создание (замещение) на более низком уровне цепочки `[[Prototype]]`. Это ограничение объясняется прежде всего целью укрепления иллюзии наследования свойств от классов. Если представить, что `foo` на более высоком уровне цепочки было унаследовано (скопировано) в `myObject`, будет логично подкрепить запрет записи для свойства `foo` в `myObject`. Тем не менее, если отделить иллюзию от факта и понять, что никакого копирования при наследовании на самом деле нет, кажется немного странным, что `myObject` запрещается иметь свойство `foo` только потому, что у другого объекта есть свойство `foo`, в которое запрещена запись. Еще более странно, что это ограничение распространяется только на присваивание `=`, но не соблюдается при использовании `Object.defineProperty(..)`. Замещение методов приводит к уродливому явному псевдополиморфизму. Обычно замещение создает слишком много сложностей и нюансов, поэтому его лучше по возможности избегать. Замещение может происходить неявно; если вы стараетесь избежать его, будьте очень внимательны.

````js
var anotherObject = {
 a: 2
};
var myObject = Object.create( anotherObject );
anotherObject.a; // 2
myObject.a; // 2
anotherObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "a" ); // false
myObject.a++; // неявное замещение!
anotherObject.a; // 2
myObject.a; // 3
myObject.hasOwnProperty( "a" ); // true
````

Хотя может показаться, что вызов `myObject.a++` должен (через делегирование) пройти по цепочке и просто увеличить свойство `anotherObject.a` «на месте», вместо этого операция `++` соответствует `myObject.a = myObject.a + 1`. В результате `[[Get]]` ищет свойство по цепочке `[[Prototype]]`, получает текущее значение `2` из `anotherObject.a`, увеличивает значение на `1`, после чего `[[Put]]` присваивает значение `3` замещенному свойству `a` в `myObject`.

## **Наследование (на основе прототипов)**

Типичный код «в стиле прототипов»:

````js
function Foo(name) {
 this.name = name;
}

Foo.prototype.myName = function() {
 return this.name;
};

function Bar(name, label) {
 Foo.call( this, name );
 this.label = label;
}

// здесь мы создаем новый объект `Bar.prototype`,
// связанный с `Foo.prototype`
Bar.prototype = Object.create( Foo.prototype );
// Внимание! Значение `Bar.prototype.constructor` исчезает.
// Возможно, вам придется вручную "исправить" его, если
// вы привыкли полагаться на такие свойства!
Bar.prototype.myLabel = function() {
 return this.label;
};

var a = new Bar( "a", "obj a" );

a.myName(); // "a"
a.myLabel(); // "obj a"
````

Самая важная часть — `Bar.prototype = Object.create( Foo.prototype )`. Вызов `Object.create(..)` создает «новый» объект на пустом месте и связывает внутреннее свойство `[[Prototype]]` этого нового объекта с объектом, заданным вами (`Foo.prototype` в данном случае). Другими словами, эта строка означает: «Создать новый объект `Bar.prototype`, связанный с `Foo.prototype`». При объявлении функции `Bar() { .. }` `Bar`, как и любая другая функция, содержит ссылку `.prototype` на свой объект по умолчанию. Но этот объект не связан с `Foo.prototype`, как бы мы хотели. Поэтому мы создаем новый объект с нужной связью, фактически отбрасывая исходный неправильно связанный объект. Многие разработчики полагают, будто каждое из двух следующих решений работает. Тем не менее они работают не так, как можно было бы ожидать:

````js
// работает не так, как вы ожидали!
Bar.prototype = Foo.prototype;
// работает более или менее так, но с побочными
// эффектами, которые, скорее всего, вам не нужны :(
Bar.prototype = new Foo();
````

Строка `Bar.prototype = Foo.prototype` не создает новый объект для связывания с `Bar.prototype`. Она просто делает `Bar.prototype` еще одной ссылкой на `Foo.prototype`, что фактически связывает `Bar` непосредственно с тем же объектом, с которым связывается `Foo: Foo.prototype`. Это означает, что при присваивании (например, `Bar.prototype.myLabel = ...`) вы изменяете не отдельный объект, а общий объект `Foo.prototype`, что повлияет на все объекты, связанные с `Foo.prototype`. `Bar.prototype = new Foo()` действительно создает новый объект, который правильно связан с `Foo.prototype`, как и требовалось. Но для этого он использует «вызов конструктора» `Foo(..)`. Если эта функция имеет какие-либо побочные эффекты (создание записей в журнале, изменение состояния, регистрация у других объектов, добавление свойств данных к `this` и т. д.), то эти побочные эффекты происходят вмомент связывания `this` (и скорее всего, с другим объектом), а не только при создании «потомков» `Bar()`, как вы, вероятно, ожидали. Итак, остается использовать `Object.create(..)` для создания нового объекта с правильным связыванием, но без побочных эффектов вызова `Foo(..)`. Небольшой недостаток заключается в том, что нам приходится создавать новый объект и терять старый, вместо того чтобы изменить существующий объект по умолчанию, который вы предоставили. Было бы удобно иметь стандартный и надежный способ изменения связи для существующего объекта. До появления ES6 существовало нестандартное и не полностью кросс-браузерное решение на базе свойства `.__proto__`. В ES6 появилась вспомогательная функция `Object.setPrototypeOf(..)`, которая решает проблему стандартным и предсказуемым образом.

````js
// до ES6
// теряет существующий объект `Bar.prototype` по умолчанию
Bar.prototype = Object.create( Foo.prototype );
// ES6+
// изменяет существующий объект `Bar.prototype`
Object.setPrototypeOf( Bar.prototype, Foo.prototype );
````


Почти с каждым объек­том **JavaScript** ассоциирован второй объект **JavaScript**, который называется про­тотипом, и первый объект наследует свойства от прототипа.

Все объекты, создаваемые объектными литералами, имеют тот же са­мый объект-прототип, на который можно ссылаться в коде **JavaScript** как на `Object.prototype`. Объекты, создаваемые с использованием ключевого слова `new` и вызова конструктора, применяют в качестве своих прототипов значение свойства `prototype` функции конструктора. Таким образом, объект, создан­ный посредством `new Object()`, наследует `Object.prototype`, как и объект, созданный с помощью `{}`. Аналогично объект, созданный с использованием
`new Array()`, применяет в качестве прототипа `Array.prototype`, а объект, со­зданный с использованием `new Date()`, получает прототип `Date.prototype`.

Почти все объекты имеют прототип, но только относительно небольшое коли­чество объектов располагают свойством `prototype` . Именно эти объекты со свойствами `prototype` определяют прототипы для всех остальных объектов.

`Object.prototype` — один из редких объектов, не имеющих прототипов: он не наследует никаких свойств. Другие объекты-прототипы являются нор­мальными объектами, которые имеют прототип.

Связанная последовательность объектов-прототипов называется цепочкой прототипов.
***

## **Наследование**

Объекты **JavaScript** имеют набор “собственных свойств” и вдобавок наследу­ют набор свойств от своих объектов-прототипов. Предположим, что вы запрашиваете свойство `х` в объекте `о`. Если в `о` отсутст
вует собственное свойство с таким именем, тогда свойство `х` запрашивается в объекте-прототипе `о`. Если объект-прототип не имеет собственного свойства по имени `х`, но сам располагает прототипом, то запрос выполняется для про­тотипа объекта-прототипа. Процесс продолжается до тех пор, пока свойство `х` не будет найдено или не обнаружится объект с прототипом `null`. Как должно быть понятно, атрибут `prototype` объекта создает цепочку или связный спи­сок, от которого наследуются свойства:

````js
let о = {}; // о наследует методы объекта от Object .prototype
o. х = 1 ; //и теперь имеет собственное свойство х.
let р = Object.create(о); //р наследует свойства от о и Object, prototype
p. у = 2; // и имеет собственное свойство у.
let q = Object.create(р); // q наследует свойства от р, о и . ..
q. z = 3; // .. .Object.prototype и имеет собственное свойство z.
let f = q.toString() ; //toString наследуется от Object .prototype
q.x + q.y // => 3; x и у наследуются от о и p
````

![Caption for the picture.](../../../../images/prototype-chain-1200w.webp)

Теперь предположим, что вы присваиваете значение свойству `х` объекта `о`. Если `о` уже имеет собственное (не унаследованное) свойство по имени `х`, тогда присваивание просто изменяет значение этого существующего свойства. В про­тивном случае присваивание создает в объекте `о` новое свойство по имени `х`. Если объект `о` ранее унаследовал свойство `х`, то унаследованное свойство скры­вается вновь созданным свойством с тем же самым именем. Присваивание свойства просматривает цепочку прототипов лишь для определения, разрешено ли присваивание. Скажем, если `о` наследует свойство
по имени `х`, допускающее только чтение, тогда присваивание не разрешается. Тем не менее, если присваивание разрешено, то оно всегда создает или устанав­ливает свойство в первоначальном объекте и никогда не модифицирует объек­ты в цепочке прототипов. Тот факт, что наследование действует при запраши­вании свойств, но не при их установке, является ключевой особенностью языка **JavaScript**, т.к. появляется возможность выборочно переопределять унаследован­ные свойства.

````js
let unitcircle = { r: 1 }; // Объект, от которого будет делаться наследование
let с = Object.create(unitcircle); // с наследует свойство r
с.х = 1; с.у = 1; // с определяет два собственных свойства
с.г = 2; // с переопределяет свое унаследованное свойство
unitcircle.г // => 1: прототип не затронут
````

Существует одно исключение из правила о том, что присваивание свойства либо терпит неудачу, либо создает или устанавливает свойство в первоначаль­ном объекте. Если `о` наследует свойство `х`, и оно является свойством средства доступа с методом установки, тогда вместо создания но­вого свойства `х` в `о` вызывается данный метод установки. Однако, метод установки вызывается с объектом `о`, а не объектом-прототипом, ко­торый определяет свойство, поэтому если метод установки определяет любые свойства, то они попадают в объект `о`, снова оставляя цепочку прототипов не­ затронутой.

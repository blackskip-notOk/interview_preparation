# **undefined & null**

Для типа **undefined** существует только одно значение: `undefined`.

Для типа **null** существует только одно значение: `null`.

***

* Ключевое слово `null` в языке **JavaScript** имеет специальное назначение и обычно используется для обозначения отсутствия значения. Оператор `typeof` для значения `null` возвращает строку `«object»`, что говорит о том, что значение `null` является специальным «пустым» объектом. Однако на практике значение `null` обычно считается единственным членом собственного типа и может использоваться как признак отсутствия значения, такого как число, строка или объект.

* Значение `undefined`, указывающее на полное отсутствие какого-либо значения. Оно возвращается при обращении к переменной, которой никогда не присваивалось значение, а также к несуществующему свойству объекта или элементу массива. Кроме того, значение `undefined` возвращается функциями, не имеющими возвращаемого значения, и присваивается параметрам функций для аргументов, которые не были переданы при вызове.
Идентификатор `undefined` является именем предопределенной глобальной переменной (а не ключевым словом, как `null`), которая инициализирована значением `undefined`. В ECMAScript 3 `undefined` является переменной, доступной для чтения/записи, которой можно
присвоить любое другое значение. Эта проблема была исправлена в ECMAScript 5, и в реализациях **JavaScript**, соответствующих этому стандарту, переменная `undefined` доступна только для чтения.
Оператор `typeof` для значения `undefined` возвращает строку «undefined», показывающую, что данное значение является единственным членом специального типа.
Многим разработчикам удобно рассматривать слово `"undefined"` как синоним для необъявленной переменной. Тем не менее в **JS** эти две концепции заметно отличаются. Неопределенная переменная (`undefined`) была объявлена в доступной области видимости, но на данный момент не содержит никакого другого значения. С другой стороны, необъявленная переменная не была формально объявлена в доступной области
видимости.

````js
var a;
a; // undefined
b; // ReferenceError: b is not defined
````

Путаница возникает из-за сообщения об ошибке, которое выдается браузерами по этому условию. Выдается сообщение `b is not defined`, очень легко и даже логично спутать его с `«переменная b со-
держит undefined»`. Тем не менее `undefined` и `not defined` — это совершенно разные понятия.

***

Несмотря на эти отличия, оба значения, `null` и `undefined`, являются признаком отсутствия значения и часто являются взаимозаменяемыми.

* Оператор равенства `==` считает их равными.
* Оба они являются ложными значениями – в логическом контексте они интерпретируются как значение `false`.
* Ни `null`, ни `undefined` не имеют каких-либо свойств или методов. На практике попытка использовать `.` или `[]`, чтобы обратиться ксвойству или методу этих значений, вызывает ошибку `TypeError`.

***

Значение `undefined` можно рассматривать как признак неожиданного или ошибочного отсутствия какого-либо значения, а null – как признак обычного или вполне ожидаемого отсутствия значения.

Как бы вы ни решили «определить» и использовать эти два значения, `null` является специальным ключевым словом, а не идентификатором, а следовательно, не может использоваться как переменная, которой можно что-то присвоить. Однако `undefined`
является идентификатором.

Если не использовать режим strict возможно присвоить значение глобальному идентификатору undefined:

```` js
function foo() {
 undefined = 2; // очень плохая мысль!
}

foo();

function foo() {
 "use strict";
 undefined = 2; // TypeError!
}

foo();
````

Однако и в режиме strict, и без него вы можете создать локальную переменную с именем undefined.

```` js
function foo() {
 "use strict";
 var undefined = 2;
 console.log( undefined ); // 2
}

foo();
````

***

## **Оператор void**

Хотя `undefined` является встроенным идентификатором, который содержит встроенное значение `undefined`, это значение также можно получить при помощи оператора `void`.

Выражение `void ___` «стирает» любое значение, так что результат выражения всегда является неопределенным. Оно не изменяет существующего значения, а всего лишь гарантирует, что операторное выражение не вернет никакого значения:

```` js
var a = 42;
console.log( void a, a ); // undefined 42
````

По принятому соглашению (в основном из языка C) для отдельного представления значения `undefined` при помощи `void` используется запись `void 0`.

Однако оператор `void` также может пригодиться в других случаях, например, если вы хотите гарантировать, что выражение не имеет возвращаемого значения (даже если оно имеет побочные эффекты).

```` js
function doSomething() {
 // примечание : `APP.ready` предоставляется приложением
 if (!APP.ready) {
 // попробовать позднее
 return void setTimeout( doSomething, 100 );
 }
 var result;
 // заняться чем-то другим
 return result;
}
// получилось с первой попытки?
if (doSomething()) {
 // заняться другими задачами
}
````

Функция `setTimeout()` возвращает числовое значение (уникальный идентификатор интервального таймера на случай, если вы захотите отменить его), но мы хотим скрыть его, чтобы возвращаемое значение нашей функции не давало ложный положительный результат.

Многие разработчики предпочитают выполнять те же действия по отдельности; такой способ работает так же, но без использования оператора void:

```` js
if (!APP.ready) {
 // попробовать позднее
 setTimeout( doSomething,100 );
 return;
}
````

В общем, если в каком-то месте вашей программы существует значение (полученное в  результате вычисления некоторого выражения), а вам было бы удобно, чтобы вместо этого значения было `undefined`, используйте оператор `void`. Скорее всего, такие ситуации будут относительно редко встречаться, но в этих редких случаях они могут быть полезны.

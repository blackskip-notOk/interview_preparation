# **Symbol**

`Symbol` — это уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов. Символьный объект — это объект-обёртка для примитивного символьного типа.

***
Чтобы создать новый символьный примитив, достаточно написать `Symbol()`, указав по желанию строку в качестве описания этого символа:

```` js
var sym1 = Symbol();
var sym2 = Symbol("foo");
var sym3 = Symbol("foo");
````

Код выше создаёт три новых символа. Заметьте, что Symbol("foo") не выполняет приведение строки "foo" к символу. Это выражение создаёт каждый раз новый символ:

```` js
Symbol("foo") === Symbol("foo"); // false
````

Код ниже с оператором `new` бросит исключение `TypeError`:

```` js
var sym = new Symbol(); // TypeError
````

Это удерживает разработчиков от создания явного объекта-обёртки Symbol вместо нового символьного значения.

Если действительно необходимо обернуть символ в объект, можно использовать функцию `Object()`:

```` js
var sym = Symbol("foo");
typeof sym;     // "symbol"
var symObj = Object(sym);
typeof symObj;  // "object"
````

***

## **Разделяемые символы в глобальном символьном реестре**

Синтаксис, использующий функцию `Symbol()`, не создаст глобальный символ, который был бы доступен в любом месте кода. Для создания символов, доступных во всех файлах и в окружении (глобальной области), используется методы `Symbol.for()` и `Symbol.keyFor()`, чтобы задать или получить символ из глобального символьного реестра (он хранит символы по строковым ключам. При обращении по ключу всегда будет возвращаться один и тот же символ.).

***

## **Поиск символьных свойств у объектов**

Метод `Object.getOwnPropertySymbols()` возвращает массив символов и позволяет получить символьные свойства конкретного объекта. При инициализации объекты не получают символьных свойств, так что этот массив будет пуст, пока вы не зададите ему какое-либо символьное свойство.

## **Свойства**

* `Symbol.length` - содержит длину, всегда равную 0 (нулю).
* `Symbol.prototype` - содержит прототип конструктора `Symbol`.

**JavaScript** имеет несколько встроенных символов, представляющих внутренние механизмы языка, которые не были доступны разработчикам в версиях **ECMAScript 5** и более ранних. Эти символы доступны посредством следующих свойств:

* `Symbol.iterator` - метод, возвращающий итератор по умолчанию для объекта. Используется конструкцией `for...of`.

* `Symbol.match` - метод для сопоставления объекта со строкой, также используемый для определения возможности объекта выступать в качестве регулярного выражения. Используется функцией `String.prototype.match()`.

* `Symbol.replace` - метод, заменяющий совпавшие подстроки в строке. Используется функцией `String.prototype.replace()`.

* `Symbol.search` - метод, возвращающий индекс вхождения подстроки, соответствующей регулярному выражению. Используется функцией `String.prototype.search()`.
* `Symbol.split` - метод, разбивающий строку на части в местах, соответствующих регулярному выражению. Используется функцией `String.prototype.split()`.

* `Symbol.hasInstance` - метод, определяющий, распознает ли конструктор некоторый объект как свой экземпляр. Используется оператором `instanceof`.

* `Symbol.isConcatSpreadable` - булево значение, показывающее, должен ли объект быть сведён к плоскому представлению в виде массива его элементов функцией `Array.prototype.concat()`.

* `Symbol.unscopables` - массив строковых имён свойств. Позволяет скрыть свойства от инструкции `with` (прежде всего для обратной совместимости).

* `Symbol.species` - метод, определяющий конструктор для порождённых объектов.

* `Symbol.toPrimitive` - метод, преобразующий объект в примитив.

* `Symbol.toStringTag` - строковое значение, используемое в качестве описания объекта по умолчанию. Используется функцией `Object.prototype.toString()`.

## **Методы**

* `Symbol.for(key)` - ищет существующие символы по заданному ключу и возвращает его, если он найден. В противном случае создаётся новый символ для данного ключа в глобальном реестре символов.

* `Symbol.keyFor(sym)` - получает по разделяемому символу его ключ из глобального реестра символов.

## **Прототип Symbol**

Все символы наследуют от `Symbol.prototype`.

***

## **Преобразование типов с символами**

* При попытке конвертировать символ в число, будет брошено исключение `TypeError` (напр., `+sym` или `sym | 0`).

* Результатом нестрогого сравнения, `Object(sym) == sym`, будет `true`.

* `Symbol("foo") + "bar"` бросает исключение `TypeError` (невозможно преобразовать символ в строку). Это удерживает разработчика от, к примеру, случайного создания строгого поля у объекта из символа.
Более  "безопасный" вызов `String(sym)` работает с символами как вызов `Symbol.prototype.toString()`. Заметьте, что в то же время `new String(sym)` бросит исключение.

***

## **Символы и конструкция `for...in`**

Символы не перечисляются при итерации `for...in`. В дополнение к этому, `Object.getOwnPropertyNames()` не вернёт символьные свойства объекта. Тем не менее, их можно получить с помощью `Object.getOwnPropertySymbols()`.

```` js
var obj = {};

obj[Symbol("a")] = "a";
obj[Symbol.for("b")] = "b";
obj["c"] = "c";
obj.d = "d";

for (var i in obj) {
   console.log(i); // выведет "c" и "d"
}
````

Это может пригодиться, когда необходимо добавить свойства объекту, который могут модифицировать другие части программы. Таким образом только вы сможете читать созданное свойство, а гарантия уникальности символов гарантирует и отсутствие конфликтов имён.

***

## **Символы и `JSON.stringify()`**

`JSON.stringify()` игнорирует свойства с ключами `Symbol`:

```` js
JSON.stringify({[Symbol("foo")]: "foo"}); // '{}'
````

***

Объекты-обёртки для `Symbol` в качестве имён свойств. Когда объект-обёртка символа используется в качестве имени свойства, этот объект сводится к символу, который он оборачивает:

```` js
var sym = Symbol("foo");
var obj = {[sym]: 1};
obj[sym];            // 1
obj[Object(sym)];    // снова 1
````

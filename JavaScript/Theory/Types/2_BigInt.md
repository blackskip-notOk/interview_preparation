# Большие числа

Тип **BigInt** был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.

***
Чтобы создать значение типа **BigInt**, необходимо добавить **n** в конец числового литерала:

```` js
    const bigInt = 1234567890123456789012345678901234567890n;
    sameBigint = BigInt("12345678901234567890123456789012345678");
    const bigintFromNumber = BigInt(10); // то же самое, что и 10n
````

***
В некотором смысле он похож на **Number**, но отличается в некоторых ключевых моментах:

* нельзя использовать с методами во встроенном объекте Math

* нельзя смешивать в операциях с любыми экземплярами **Number**:

```` js
alert(1n + 2); // Error: Cannot mix BigInt and other types
````

Чтобы использовать **BigInt** вместе с **Number** нужно явно их конвертировать используя либо BigInt(), либо Number(), например:

```` js
    let bigint = 1n;
    let number = 2;
    // конвертируем number в bigint
    alert(bigint + BigInt(number)); // 3
    // конвертируем `bigint` в number
    alert(Number(bigint) + number); // 3
````

* Не поддерживаемый унарный оператор (+):

```` js
let bigint = 1n;
alert( +bigint ); // SyntaxError: Unexpected identifier
````

* Не поддерживается побитовый сдвиг вправо с заполнением нулями **>>>**

* При использовании оператора **/** результат будет округляться в меньшую сторону, то есть она не будет возвращать какие-либо дробные цифры

```` js
alert(5n / 2n); // 2
````

* Использование JSON.stringify() с любым значением типа BigInt приведёт к TypeError, поскольку значения BigInt не преобразуется в JSON по умолчанию, однако вы можете реализовать свой собственный метод toJSON, если вам необходимо:

```` js
BigInt.prototype.toJSON = function() { return this.toString() }
//Теперь вместо ошибки, JSON.stringify будет создавать строку:
JSON.stringify(BigInt(1))
// '"1"'
````

***

Следующие операторы могут использоваться с **BigInt** (или объектом-обёрткой BigInt): `+, *, -, **, %`. Побитовые операции также поддерживаются (кроме `>>>`).

Конвертирование bigint в число всегда происходит неявно и без генерации ошибок, но если значение bigint слишком велико и не подходит под тип number, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.

Операции сравнения, такие как `<, >`, работают с bigint и обычными числами как обычно:

```` js
alert( 2n > 1n ); // true
alert( 2n > 1 ); // true
````

Обычные и bigint числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении ==:

```` js
alert( 1 == 1n ); // true
alert( 1 === 1n ); // false
````

В if или любом другом логическом операторе bigint число ведёт себя как обычное число. 0n преобразуется в false, другие значения преобразуются в true. Логические операторы ||, && и другие также работают с bigint числами как с обычными числами:

```` js
alert( 1n || 2 ); // 1
alert( 0n || 2 ); // 2
````

BigInt могут быть смешаны в массивах c Number и отсортированы:

```` js
const mixed = [4n, 6, -12n, 10, 4, 0, 0n];
// ↪  [4n, 6, -12n, 10, 4, 0, 0n]

mixed.sort();
// ↪ [-12n, 0, 0n, 10, 4n, 4, 6]
````

Сравнения с обьектом-обёрткой BigInt действуют как с другими объектами, указывая на равенство только когда сравнивается идентичный экземпляр объекта:

```` js
0n === Object(0n); // false
Object(0n) === Object(0n); // false

const o = Object(0n);
o === o // true
````

# **Массив**

## **Ссылки**

* [**Создание массивов**](#создание-массивов)
* [**литералы типа массивов**](#литералы-типа-массивов)
* [**конструктор `Array()`**](#конструктор-array)
* [**Array.of()**](#arrayof)
* [**Array.from()**](#arrayfrom)

Массив представ­ляет собой упорядоченную коллекцию значений. Массивы **JavaScript** являются нетипизированными: элемент масси­ва может относиться к любому типу, а разные элементы одного массива могут иметь отличающиеся типы. Индексы в массивах **JavaScript** начи­наются с нуля и представляют собой 32-битные числа: наибольший возможный индекс составляет 4294967294 для максимального размера массива в 4294967295 элементов.

Массивы **JavaScript** являются динамическими: по мере надобности они увеличиваются или умень­шаются, а при создании массива нет необходимости объявлять для него фиксированный размер или повторно размещать в памяти в случае изменения его размера. Массивы **JavaScript** могут быть разреженными: элементы не обязаны иметь смежные индексы, поэтому возможно наличие брешей. Каждый мас­сив **JavaScript** имеет свойство `length`. Для неразреженных массивов свойство `length` указывает количество элементов в массиве. Для разреженных массивов значение `length` больше самого высокого индекса любого элемента. Массивы **JavaScript** являются специализированной формой объекта **JavaScript**, и в действительности индексы массивов — не многим более чем имена свойств, которые просто оказались целыми числами. Реализации обычно оптимизируют массивы, так что доступ к элементам массива с числовой индексаций, как правило, выполня­ется гораздо быстрее, нежели доступ к обыкновенным свойствам объектов. Массивы наследуют свойства от `Array.prototype`, который определяет богатый набор методов манипулирования массивами.

## **Создание массивов**

### **литералы типа массивов**

````js
let empty = []; // Массив без элементов
let primes = [2, 3, 5, 7, 11]; // Массив с пятью числовыми элементами
let misc = [ 1.1, true, "а", ]; // Три элемента различных типов
// плюс хвостовая запятая
````

Значения литерала типа массива не обязательно должны быть константами:

````js
let base = 1024;
let table = [base, base+1, base+2, base+3];
````

Литералы типа массивов могут содержать объектные литералы или другие литералы типа массивов:

````js
let b = [[1, {х: 1, у: 2}], [2, {х: 3, у: 4}]];
````

Если литерал типа массива в какой-то строке содержит множество запятых без значений между ними, тогда массив будет разреженным. Элементы массива, для которых значения опущены, не существуют, но в случае их запрашивания представляются как `undefined`:

````js
let count = [ 1, ,3]; // Элементы находятся по индексам 0 и 2.
//По индексу 1 элемента нет
let undefs =[,,]; // Массив, не содержащий элементов,
//но имеющий длину 2
````

Синтаксис литералов типа массивов допускает наличие дополнительной хвостовой запятой, так что `[,, ]` имеет длину 2, а не 3.
***

### **операции распространения**

В ES6 и более новых версиях можно применять “операцию распространения” `...`, чтобы помещать элементы одного массива внутрь литерала типа массива:

````js
let а = [1, 2, 3];
let b = [О, ...а, 4]; // b == [0, 1, 2, 3, 4]
````

Многоточие “распространяет” массив `а`, так что его элементы становятся элементами создаваемого литерала типа массива. Результат получается такой же, как если бы конструкция `...а` была заменена элементами массива `а`, пере­численными буквально внутри включающего литерала типа массива. (Обратите внимание, что хотя мы называем многоточие операцией распространения, это не подлинная операция, поскольку ее можно использовать только в литералах типа массивов и в вызовах функций.) Операция распространения обеспечивает удобный способ создания (неглу­бокой) копии массива:

````js
let original = [1,2,3];
let copy = [...original];
copy[0] = 0 ; // Модификация копии не приводит к изменению оригинала
original[0] // => 1
````

Операция распространения работает с любым итерируемым объектом. Строки итерируемы, поэтому вы можете при­
менять операцию распространения для превращения любой строки в массив односимвольных строк:

````js
let digits = [..."0123456789ABCDEF"];
digits // => ["0",”1","2","3",”4","5”,"б",”7",”8”,"9",
// "А","В","С","D","Е", "F"]
````

Объекты множеств `Set` итерируемы, так что легкий способ удаления дублированных элементов из массива предусматривает его преобразование в объект множества и затем немедленное преобразование мно­жества в массив с использованием операции распространения:

````js
let letters = [__"hello world"];

[...new Set(letters)] // => ["h","e","1","o"," ","w","r","d"]
````

***

### **конструктор `Array()`**

Конструктор `Array()` можно вызывать тремя путями:

* Вызов без аргументов:
`let а = new Array();` Такая методика создает пустой массив без элементов и эквивалентен лите­ралу типа массива `[]`.

* Вызов с одиночным числовым аргументом, который указывает длину: `let а = new Array(10);` Такая методика создает массив с указанной длиной. Эту форму конструк­тора `Array()` можно использовать для предварительного размещения массива, когда заранее известно, сколько элементов потребуется. Важно отметить, что в результирующем массиве нет никаких значений, а свойс­тва индексов массива "0”, “1” и т.д. даже не определены.

* Явное указание двух и более элементов массива или одиночного нечисло­вого элемента: `let а = new Array(5, 4, 3, 2, 1, "testing, testing");` В такой форме аргументы конструктора становятся элементами нового массива.

***

### **Array.of()**

`Array.of()` пред­ставляет собой фабричный метод, который создает и возвращает новый массив, используя значения своих аргументов (независимо от их количества) в качестве элементов массива: `Array.of() //=>[];` при вызове без аргументов возвращает пустой массив `Array.of (10) // => [10];` при вызове с единственным числовым аргументом способна создавать массивы `Array.of(1,2,3) // => [1, 2, 3]`
***

### **Array.from()**

`Array.from` — еще один фабричный метод, введенный в **ES6**. Он ожидает в первом аргументе итерируемый или похожий на массив объект и возвращает новый массив, который содержит элементы переданного объекта. С итерируемым аргументом `Array.from(iterable)` работает подобно операции распро­странения `[...iterable]`. Кроме того, она предлагает простой способ для по­ лучения копии массива:
`let сору = Array.from(original);` Метод `Array.from()` также важен оттого, что он определяет способ созда­ния копии в виде подлинного массива из объекта, похожего на массив. Объекты, похожие на массивы, не являются объектами массивов, которые имеют число­вое свойство длины и значения, сохраненные с помощью свойств с именами в форме целых чисел. При написании кода **JavaScript** на стороне клиента возвращаемые значения некоторых методов веб-браузеров похожи на массивы, и брабатывать такие значения может быть легче, если сначала преобразовать их в подлинные массивы:

````js
let truearray = Array.from(arraylike);
````

Метод `Array.from()` принимает необязательный второй аргумент. Если вы передадите во втором аргументе функцию, тогда в ходе построения ново­го массива каждый элемент из исходного объекта будет передаваться указан­ной функции, а возвращаемое ею значение будет сохраняться в массиве вместо первоначального значения.
***

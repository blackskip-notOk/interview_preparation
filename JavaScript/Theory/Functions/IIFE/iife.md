# **IIFE**

Если взять любой фрагмент кода и «завернуть» его в функцию, вы фактически скроете все внутренние объявления переменных и функций от внешней области видимости во внутренней области видимости этой функции.

````js
var a = 2;

function foo() {
 var a = 3;
 console.log( a ); // 3
}

foo();

console.log( a ); // 2
````

Этот прием создает ряд проблем. Во-первых, приходится объявлять именованную функцию `foo()`, а значит, имя идентификатора `foo` само «загрязняет» внешнюю область видимости (глобальную в данном случае). Также для выполнения внутреннего кода функцию приходится вызывать по имени. Было бы удобнее, если бы функция обходилась без имени (а вернее, имя не загрязняло внешнюю область видимости) и при этом могла выполняться автоматически.

````js
var a = 2;

(function foo(){
 var a = 3;
 console.log( a ); // 3
})();

console.log( a ); // 2
````

* Команда `function` для обертки начинается с `(function…` вместо обычного `function…`. Вместо того чтобы интерпретировать функцию как стандартное объявление, мы интерпретируем ее как функциональное выражение. Объявление проще всего отличить от выражения по позиции слова `function` в команде (не просто строке, а в отдельной команде). Если команда начинается с `function`, значит, это объявление функции. В противном случае это функциональное выражение. Ключевое различие между объявлением функции и функциональным выражением относится к тому, где имя связывается с идентификатором. В первом фрагменте имя `foo` связывается с внешней областью видимости, и мы вызываем его напрямую `foo()`. Во втором фрагменте имя `foo` не связывается с внешней областью видимости, а только со своей функцией. Иначе говоря, `(function foo(){ .. })` как выражение означает, что идентификатор `foo` находится только в области видимости, в которой находится, а не во внешней области видимости. Сокрытие имени `foo` означает, что оно не будет без необходимости загрязнять внешнюю область видимости.

* Первая пара `()` преобразует функцию в выражение, а вторая пара `()` выполняет функцию. Этот паттерн настолько распространен, что сообщество выработало для него специальный термин: IIFE («Immediately Invoked Function Expression»). Для **IIFE** имена не обязательны, в самой распространенной форме **IIFE** используется анонимное функциональное выражение.

* У традиционной формы **IIFE** существует небольшая вариация, которую предпочитают некоторые разработчики: `(function() { .. }())`. В этой форме вызывающие круглые скобки `()` перемещаются внутрь внешней пары `()`. Эти две формы имеют идентичную функциональность. Выбор определяется исключительно стилистическими предпочтениями.

* Другая распространенная вариация на тему **IIFE** — использование того факта, что они по сути являются вызовами функций для передачи аргументов.

````js
var a = 2;

(function IIFE(global){
 var a = 3;
 console.log(a); // 3
 console.log(global.a); // 2
})(window);

console.log(a); // 2
````

Другое применение этого паттерна решает (второстепенную и специфическую) проблему с некорректной перезаписью значений идентификатора `default` по умолчанию, приводящей к неожиданным результатам. Если присвоить параметру имя `undefined`, но не передать значение этого аргумента, можно гарантировать, что идентификатор `undefined` действительно соответствует неопределенному значению в блоке кода:

````js
undefined = true;

(function IIFE(undefined) {
 var a;
 if (a === undefined) {
 console.log("Undefined is safe here!");
 }
})();
````

* Еще одна вариация на тему **IIFE** меняет порядок вещей: выполняемая функция передается в последнюю очередь, после вызова и передаваемых параметров. Этот паттерн используется в проекте **UMD** (Universal Module Definition).

````js
var a = 2;

(function IIFE(def) {
 def(window);
})(function def(global) {
 var a = 3;
 console.log(a); // 3
 console.log(global.a); // 2
});
````

Функциональное выражение `def` определяется во второй половине фрагмента, а затем передается как параметр (также с именем `def`) функции **IIFE**, определяемой в первой половине фрагмента. Наконец, параметр `def` (функция) вызывается с передачей `window` как параметра `global`.

````js
var a = 1;
console.log(a); // 1

/** iife - создаём область видимости
 * - переменная a в ней не определена
 * - ищем a в глобальной области
 * - перезаписываем глобальную переменную
 */
(function() {
  console.log(a); // 1
  a = 2;
})();

/** iife - создаём область видимости
 * - переменная a в ней определена через var
 * - var всплывает внутри функциональной области
 * - так как a определена и всплыла выводим undefined
 * - присваиваем локальной a значение 2
 */

(function() {
  console.log(a); // undefined
  var a = 3;
})();

/** выводим глобальную a */

console.log(a); // 2

/** iife - создаём область видимости
 * - переменная a в ней определена через let
 * - let не всплывает внутри функциональной области (вернее всплывает, но попадает в temporary dead zone)
 * - так как a определена, но не всплыла, пытаемся обратиться к локальной a и получаем reference error
 * - присваиваем локальной a значение 4
 */

(function() {
  console.log(a); // reference error
  let a = 4;
})();

/** выводим глобальную a */

console.log(a); // 2

/** iife - создаём область видимости
 * - вызываем функцию f
 * - так как f объявлена с помощью function declaration, то её можно вызвать до объявления - она всплывает
 * - выполняется f, в консоль выводим 1
 * - присваиваем f новую функцию
 * - вызываем f снаружи iife
 * - так как переприсвоили f новую функцию, выполняем её и в консоль выводим 1
 */

(function() {
 f(); // 2
 f = function() {
  console.log(1);
 }
})();

f(); //1

function f() {
 console.log(2);
}

````

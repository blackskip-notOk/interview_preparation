# **Layout, Painting и Compositing**

## **Ссылки**

* [**event loop**](#event_loop)
* [**layout**](#layout)
* [**painting**](#painting)
* [**compositing**](#compositing)
* [**Как оптимизировать рендер**](#как-оптимизировать-рендер)

***

**CSSOM** (объектная модель **CSS**) похожа на **DOM**. Браузер преобразует **CSS** файлы в карту стилей. Браузер считывает каждый набор правил в **CSS**, создаёт дерево узлов, основываясь на **CSS** селекторах. **CSSOM** дерево включает в себя стили пользовательского агента - это стили, которые браузер вставляет по умолчанию. Браузер начинает построение модели с наиболее общих правил для каждого узла, постепенно применяя более специфичные правила. Другими словами, он применяет правила каскадно. Отсюда и название **CSS - Cascading Style Sheets**. Построение **CSSOM** происходит очень быстро и не отображается отдельным цветом в средствах разработчика. Оно настолько быстрое, что чаще всего включается в показатель "Повторное вычисление стилей (Recalculate Styles)" в средствах разработчика. Этот показатель показывает общее время обработки стилей - обработку **CSS**, построение **CSSOM** и рекурсивное вычисление стилей.

Этапы рендеринга включают в себя стилизацию, компоновку (**layout**), отрисовку (**paint**) и, в некоторых случаях, композицию (**composition**). **CSSOM** и **DOM** деревья, созданные на предыдущем этапе комбинируются в дерево рендера, которое затем используется для расчёта положения каждого видимого элемента. После этого элементы будут отрисованы на экране. В некоторых случаях содержимое может быть вынесено на отдельные слои и совмещено (**composition**) - такой подход увеличивает производительность, позволяя отрисовывать содержимое экрана на графическом процессоре вместо ЦПУ. Это освобождает основной поток.

## **layout**

Шаг макетирования — это расчёт, сколько места элемент занимает на экране. Изменение свойства 'layout' в CSS (например, ширина, высота) означает, что браузеру придётся проверить все остальные элементы и перерисовать страницу.
На веб-странице практически все элементы прямоугольны (box). На начальной фазе браузер, учитывая размер видимой области, определяет какие размеры разных элементов должны быть на экране. Использует размер видимой области как базис, процесс начинает вычисление с элемента `body`, затем переходит к его потомкам, вычисляет размеры каждого элемента и резервирует место для тех элементов, размеры которых он ещё не знает (например, изображения).
Момент, когда позиция и размеры узлов вычислены, называется **layout**. Последующие вычисления позиций и размеров называются **reflow**.
**Layout** — это очень болезненная операция для современных веб-сайтов. Болезненна она потому, что наиболее тяжелый **style recalculation** происходит при первом рендере, а вот **Layout** происходит при:

1. Чтении свойств влияющих на размер и положение элементов (`offsetWidth`, `offsetLeft`, `getBoundingClientRect`, и т.д.)
2. При записи свойств, влияющих на размер и положение элементов, за исключением некоторых свойств, вроде `transform` и `will-change`. Для `transform` браузер задействует `composition` процесс, а в случае с `will-change` браузер попытается использовать `composition`.

**Layout** отвечает за:

* Вычисление слоев
* Расчет взаиморасположения элементов на слое
* Расчет влияния одних элементов на другие

**Layout** (а вместе с ним **raf** и **Style**) может происходить не в свою очередь, когда нужно отрендерить страницу и применить изменения, а тогда, когда **JS** изменил размеры элементов или считал данные. Такой процесс называется **force layout**. Полный [список свойств](https://gist.github.com/paulirish/5d52fb081b3570c81e3a), который приводит браузер к остановке исполнения **JS** и вызову **Layout**.

````js
div1.style.height = "200px"; // Изменили размер элемента
const height1 = div1.clientHeight; // Считываем его размер
````

Браузер не сможет рассчитать `clientHeight` `div1` без пересчета его реальных размеров. В этом случае, браузер приостановит исполнение **JS** кода (совсем) и выполнит по очереди: **Style** (чтобы определить, что изменять), **Layout** (чтобы определить, как изменилось). **Layout** должен рассчитать не только элементы, которые находятся перед, но и после `div1`. Современные браузеры оптимизируют расчет так, чтобы не пересчитывать абсолютно все дерево. Но в худшем случае этого не избежать. Процесс пересчета элементов называется **Layout Shift**.

Также браузеры пытаются не форсить **layout** каждый раз. Поэтому, чтобы выиграть по скорости операции чтения и записи группируют:

````js
div1.style.height = "200px";
var height1 = div1.clientHeight; // <-- layout 1
div2.style.margin = "300px";
var height2 = div2.clientHeight; // <-- layout 2
````

В этом коде браузер запланировал изменение высоты `div1` до `200px`, но затем получил задачу на считывание. Пришлось сделать **layout**. Затем ситуация повторилась. Обратите внимание, браузер не произвел **layout** на операциях записи. Потому что в этот момент нужные данные у него уже были.

Если сгруппировать чтение и запись:

````js
div1.style.height = "200px";
div2.style.margin = "300px";
var height1 = div1.clientHeight; // <-- layout 1
var height2 = div2.clientHeight;
````

это позволяет избежать второго **layout**, потому что браузер уже посчитал расположение элементов.
**Layout** работает со "слоями" в потоке. Посмотреть на то, как браузер выделяет слои можно в **chrome devtools -> More tools -> layers**.

Базовые советы для оптимизации **layout**:

* Уменьшать количество **DOM** нод
* По возможности избегать **force layout**
* Компоновать чтение и запись свойств

***

## **painting**

отрисовка каждого отдельного узла на экране. Момент, когда это происходит впервые, называется **first meaningful paint** (первая значащая отрисовка). Во время фазы отрисовки или растеризации, браузер конвертирует каждый контейнер **box** в настоящие пиксели на экране. Отрисовка подразумевает рисование каждой визуальной частицы элемента на экране (текст, цвета, границы, тени) и рисование заменяемых элементов (картинки, кнопки). Чтобы обеспечить плавную прокрутку и анимацию, отрисовка каждого элемента занимает весь основной поток. Сюда включается вычисление стилей, повторное вычисление стилей и отрисовка. Все эти этапы должны выполняться не дольше 16.67 мс. (1000мс. / 60 кадров в секунду). Для того, чтобы сделать инициирующую и повторную отрисовки быстрее, можно разбить весь процесс на несколько слоёв. Когда это случается - становится необходима **композиция**. Отрисовка может разбить элементы в дереве рендера на слои. Для того, чтобы ускорить их рендер, браузер может перенести отрисовку разных слоёв на **GPU** (вместо основного потока **CPU**). Для переноса вычислений отрисовки на **GPU** вы можете использовать некоторые специальные **HTML** теги, например `<video>` и `<canvas>`; а также CSS-свойства `opacity`, `transform` и `will-change`. Узлы, созданные таким образом, будут отрисованы на их собственном слое, вместе с их потомками, если только потомки сами по себе не будут вынесены в отдельные слои. Слои улучшают производительность. Но, с точки зрения управления памяти, они неэффективны. Поэтому старайтесь не использовать их там, где в нет необходимости. На отрисовку зачастую уходит больше всего времени при рендеринге.

***

## **compositing**

Композиция — это шаг, на котором браузер должен отрисовать слои в правильном порядке. Поскольку некоторые элементы могут перекрывать друг друга, на этом этапе браузер проверяет, что элементы отображаются в указанном порядке.
Если вы измените свойство CSS, которое не затрагивает ни макет, ни отрисовку, то браузеру остаётся сделать только композицию. Это единственная операция, которая в классическом веб-сайте исполняется с помощью **GPU**. На этом этапе браузер исполняет специфические **CSS** стили, например `transform`. Важное дополнение: само по себе свойство `transform: translate` не включает рендер элемента на видеокарте. То есть сделав `transform: translateZ(0)` вы не "перенесете элемент на видеокарту", это заблуждение. Однако современные браузеры могут сами переносить часть операций на **GPU**. Именно с помощью `transform` советуют создавать сложные анимации. Секрет довольно прост:
    1. Анимация на t`ransform` позволяет не вызывать **layout** каждый кадр
    2. Она позволяет избавиться от артефактов "мыльца" при анимациях, которые иногда бывают при анимировании `left`, `right`, `top`, `bottom`
В то же время, верстать весь сайт только через `transform` не рекомендуется, так как это приводит к своим тормозам. Важно совмещать правильно верстку.

## **Как оптимизировать рендер**

Самая тяжелая операция для рендера кадра (для большинства сайтов) — *layout**. При сложных анимациях каждый кадр может пересчитываться все элементы в **DOM**. Это ведет к пропуску кадров и проблемам с производительностью сайта.

1. Вынести анимации на **CSS**. Исполнение **JS** кода не бесплатно
2. Изменяйть `transform` свойство для “перемещения” объектов
3. Использовать `will-change` свойство — это свойство, которое позволяет браузерам "подготовить" дом элемент к изменениям определенных стилей. Важно — это свойство помогает браузеру понять, что разработчик запланировал изменить. Это свойство нельзя применять к большому количеству элементов, иначе получите тормоза.
4. Использовать батчевые изменения в **DOM**
5. Использовать **requestAnimationFrame** для планирования изменений в следующем кадре
6. Комбинировать задачи на запись\чтение свойств элементов. Обращать внимание на вызовы свойств, которые форсят **layout**.
7. При возникновении сложных ситуаций, лучше всего запустить профилировщик и посмотреть на частоту и время вызовов. Это даст информацию о том, какой этап тормозит, оптимизировать каждый этап отдельно.

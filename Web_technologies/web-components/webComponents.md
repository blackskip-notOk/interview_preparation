# **Web-components**

## **Ссылки**

***

**Веб-компоненты** - это набор различных технологий и стандартов, позволяющих создавать повторно используемые настраиваемые HTML-элементы с их функциональностью, инкапсулированными DOM и стилями.

## **Веб-компоненты** состоят из трёх основных технологий

### **Пользовательские элементы (Custom Elements)**

Это набор API-интерфейсов **JavaScript**, позволяющих определять пользовательские элементы и их поведение, которые затем можно использовать по желанию в пользовательском интерфейсе.
Существует два вида пользовательских элементов:

* Автономные пользовательские элементы – «полностью новые» элементы, расширяющие абстрактный класс `HTMLElement`.
* Пользовательские встроенные элементы – элементы, расширяющие встроенные, например кнопку `HTMLButtonElement` и т.п.

Чтобы создать автономный пользовательский элемент, нужно сообщить браузеру ряд деталей: как его показать, что делать, когда элемент добавляется или удаляется со страницы и т.д. Это делается путём создания класса со специальными методами.

````js
class MyElement extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    // браузер вызывает этот метод при добавлении элемента в документ
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }

  disconnectedCallback() {
    // браузер вызывает этот метод при удалении элемента из документа
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }

  static get observedAttributes() {
    return [/* массив имён атрибутов для отслеживания их изменений */];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // вызывается при изменении одного из перечисленных выше атрибутов
  }

  adoptedCallback() {
    // вызывается, когда элемент перемещается в новый документ
    // (происходит в document.adoptNode, используется очень редко)
  }

  // у элемента могут быть ещё другие методы и свойства
}
````

После этого нужно зарегистрировать элемент. Имя пользовательского элемента должно содержать дефис "-" (`my-element`). Это гарантирует отсутствие конфликтов имён между встроенными и пользовательскими элементами **HTML**.

````js
customElements.define("my-element", MyElement);
````

Теперь для любых HTML-элементов с тегом `<my-element>` создаётся экземпляр `MyElement` и вызываются вышеупомянутые методы. Также можно использовать `document.createElement('my-element')`.



2. **Shadow DOM**: набор API-интерфейсов **JavaScript** для прикрепления инкапсулированного «теневого» дерева DOM к элементу, который отображается отдельно от DOM основного документа, и управления соответствующими функциями. Таким образом, вы можете сохранить функции элемента в секрете, поэтому для них можно создавать сценарии и стили, не опасаясь коллизий с другими частями документа.
3. **HTML templates**: элементы `<template>` и `<slot>` позволяют создавать шаблоны разметки, которых не видно на отображаемой странице. Затем их можно многократно использовать в качестве основы структуры настраиваемого элемента.

## **Базовый подход к реализации веб-компонента**

1. Создаётся класс, в котором указывается функциональность веб-компонента.
2. Регистрируется новый настраиваемый элемент с помощью метода `CustomElementRegistry.define()`, передав ему имя элемента, класс или функцию, и, необязательно, от какого элемента он наследуется.
3. При необходимости прикрепляется теневая DOM к настраиваемому элементу с помощью метода `Element.attachShadow()`. Добавляются дочерние элементы, обработчики событий и т.д. в теневой DOM, используя обычные методы DOM.
4. При необходимости определяется **HTML template**, используя `<template>` и `<slot>`.

***

## **Обновление пользовательских элементов**

Если браузер сталкивается с пользовательскими элементами до `customElements.define`, то это не ошибка. Но элемент пока неизвестен, как и любой нестандартный тег. Такие «неопределённые» элементы могут быть стилизованы с помощью **CSS** селектора `:not(:defined)`. Когда вызывается `customElements.define`, они «обновляются» и становятся `:defined`. Чтобы получить информацию о пользовательских элементах, есть следующие методы:

* `customElements.get(name)` – возвращает класс пользовательского элемента с указанным именем `name`
* `customElements.whenDefined(name)` – возвращает промис, который переходит в состояние «успешно выполнен» (без значения), когда определён пользовательский элемент с указанным именем `name`.


# **Web-components**

## **Ссылки**

* [**Custom Elements**](./customElements.md)
* [**Shadow DOM**](./shadowDom.md)
* [**HTML templates**](./template%26%26slot.md)
* [**Настройка стилей теневого DOM**](./shadowDomStyles.md)
* [**Теневой DOM и события**](./shadowDomEvents.md)
* [**Использование React в веб-компонентах**](#использование-react-в-веб-компонентах)

***

**Веб-компоненты** - это набор различных технологий и стандартов, позволяющих создавать повторно используемые настраиваемые HTML-элементы с их функциональностью, инкапсулированными DOM и стилями.
***

## **Веб-компоненты** состоят из трёх основных технологий

1. [**Пользовательские элементы (Custom Elements)**](./customElements.md). Это набор API-интерфейсов **JavaScript**, позволяющих определять пользовательские элементы и их поведение, которые затем можно использовать по желанию в пользовательском интерфейсе.

2. [**Shadow DOM**](./shadowDom.md). Набор API-интерфейсов **JavaScript** для прикрепления инкапсулированного «теневого» дерева DOM к элементу, который отображается отдельно от DOM основного документа, и управления соответствующими функциями. Таким образом, вы можете сохранить функции элемента в секрете, поэтому для них можно создавать сценарии и стили, не опасаясь коллизий с другими частями документа.

3. [**HTML templates**](./template%26%26slot.md). Элементы `<template>` и `<slot>` позволяют создавать шаблоны разметки, которых не видно на отображаемой странице. Затем их можно многократно использовать в качестве основы структуры настраиваемого элемента.

## **Базовый подход к реализации веб-компонента**

1. Создаётся класс, в котором указывается функциональность веб-компонента.
2. Регистрируется новый настраиваемый элемент с помощью метода `CustomElementRegistry.define()`, передав ему имя элемента, класс или функцию, и, необязательно, от какого элемента он наследуется.
3. При необходимости прикрепляется теневая DOM к настраиваемому элементу с помощью метода `Element.attachShadow()`. Добавляются дочерние элементы, обработчики событий и т.д. в теневой DOM, используя обычные методы DOM.
4. При необходимости определяется **HTML template**, используя `<template>` и `<slot>`.

***

## **Использование React в веб-компонентах**

````js
class XSearch extends HTMLElement {
  connectedCallback() {
    const mountPoint = document.createElement('span');
    this.attachShadow({ mode: 'open' }).appendChild(mountPoint);

    const name = this.getAttribute('name');
    const url = 'https://www.google.com/search?q=' + encodeURIComponent(name);
    ReactDOM.render(<a href={url}>{name}</a>, mountPoint);
  }
}
customElements.define('x-search', XSearch);
````

Примечание: Данный код не будет работать, если вы преобразуете классы с помощью **Babel**. Добавьте шим `custom-elements-es5-adapter` перед загрузкой веб-компонентов, чтобы решить эту проблему.

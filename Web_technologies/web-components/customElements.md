# **Пользовательские элементы (Custom Elements)**

## **Ссылки**

* [**Автономные пользовательские элементы**](#автономные-пользовательские-элементы)
* [**Пользовательские встроенные элементы**](#пользовательские-встроенные-элементы)

Существует два вида пользовательских элементов:

## **Автономные пользовательские элементы**

«полностью новые» элементы, расширяющие абстрактный класс `HTMLElement`.**

Чтобы создать автономный пользовательский элемент, нужно сообщить браузеру ряд деталей: как его показать, что делать, когда элемент добавляется или удаляется со страницы и т.д. Это делается путём создания класса со специальными методами.

````js
class MyElement extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    // браузер вызывает этот метод при добавлении элемента в документ
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }

  disconnectedCallback() {
    // браузер вызывает этот метод при удалении элемента из документа
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }

  static get observedAttributes() {
    return [/* массив имён атрибутов для отслеживания их изменений */];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // вызывается при изменении одного из перечисленных выше атрибутов
  }

  adoptedCallback() {
    // вызывается, когда элемент перемещается в новый документ
    // (происходит в document.adoptNode, используется очень редко)
  }

  // у элемента могут быть ещё другие методы и свойства
}
````

После этого нужно зарегистрировать элемент. Имя пользовательского элемента должно содержать дефис "-" (`my-element`). Это гарантирует отсутствие конфликтов имён между встроенными и пользовательскими элементами **HTML**.

````js
customElements.define("my-element", MyElement);
````

Теперь для любых HTML-элементов с тегом `<my-element>` создаётся экземпляр `MyElement` и вызываются вышеупомянутые методы. Также можно использовать `document.createElement('my-element')`.
***

## **Пользовательские встроенные элементы**

элементы, расширяющие встроенные, например кнопку `HTMLButtonElement` и т.п. Новые элементы, такие как `<my-element>`, не имеют связанной с ними семантики. Они не известны поисковым системам, а устройства для людей с ограниченными возможностями не могут справиться с ними. Мы можем расширять и модифицировать встроенные HTML-элементы, наследуя их классы. Например, кнопки `<button>` являются экземплярами класса `HTMLButtonElement`.

````js
<script>
class HelloButton extends HTMLButtonElement {
  constructor() {
    super();
    this.addEventListener('click', () => alert("Привет!"));
  }
}

customElements.define('hello-button', HelloButton, {extends: 'button'});
</script>

<button is="hello-button">Нажми на меня</button>
````

***

## **Обновление пользовательских элементов**

Если браузер сталкивается с пользовательскими элементами до `customElements.define`, то это не ошибка. Но элемент пока неизвестен, как и любой нестандартный тег. Такие «неопределённые» элементы могут быть стилизованы с помощью **CSS** селектора `:not(:defined)`. Когда вызывается `customElements.define`, они «обновляются» и становятся `:defined`. Чтобы получить информацию о пользовательских элементах, есть следующие методы:

* `customElements.get(name)` – возвращает класс пользовательского элемента с указанным именем `name`
* `customElements.whenDefined(name)` – возвращает промис, который переходит в состояние «успешно выполнен» (без значения), когда определён пользовательский элемент с указанным именем `name`.

***

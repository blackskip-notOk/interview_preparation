# **Cross-Origin Resource Sharing (CORS)**

## **Same-Origin Policy**

Эта ограничительная мера была придумана разработчиками браузеров что бы веб-сайт не мог получить ответ на сгенерированный AJAX запрос к другому веб-сайту находящемуся по другому адресу. Например: если вы заходите на sample.org, вы бы не хотели, чтобы этот веб-сайт отправлял запрос к примеру на ваш банковский веб-сайт и получал баланс вашего счета и транзакции. **Same-Origin Policy** предотвращает именно это. «Источник (origin)» в этом случае состоит из:

* протокол (например http)
* хост (например example.com)
* порт (например 8000)

Так что <http://sample.org> и <http://www.sample.org> и <http://sample.org:3000> — это три разных источника.

**Cross-Origin Resource Sharing (CORS)** — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

* Пример cross-origin запроса: **HTML** страница, обслуживаемая сервером с **<http://domain-a.com>**, запрашивает `<img>` **src** по адресу **<http://domain-b.com/image.jpg>**. Сегодня многие страницы загружают ресурсы вроде CSS-стилей, изображений и скриптов с разных доменов, соответствующих разным сетям доставки контента (Content delivery networks, CDNs).

В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, **XMLHttpRequest** и **Fetch API** следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.
Механизм **CORS** поддерживает кросс-доменные запросы и передачу данных между браузером и web-серверами по защищённому соединению. .

Стандарт cross-origin обмена используется для разрешения кросс-сайтовых HTTP запросов для:

* Вызова **XMLHttpRequest** или **Fetch APIs** в кросс-сайт манере, как описано выше.
* Web Fonts (для кросс-доменного использования шрифтов в @font-face в рамках CSS), чтобы серверы могли разворачивать TrueType шрифты, которые могут быть загружены только кросс-сайт и использованы web-сайтами, которым это разрешено.
* WebGL текстуры.
* Фреймы с изображениями/видео, добавленными в канвас с помощью drawImage.
* Стили (для CSSOM доступа).
* Скрипты (для  отключённых исключений).

Стандарт Cross-Origin Resource Sharing работает с помощью добавления новых HTTP-заголовков, которые позволяют серверам описывать набор источников, которым разрешено читать информацию, запрашиваемую web-браузером. В частности, для методов HTTP-запросов, которые могут привести к побочным эффектам над данными сервера (в частности, для HTTP методов, отличных от GET или для POST запросов, использующих определённые MIME-типы), спецификация требует, чтобы браузеры "предпроверяли" запрос, запрашивая поддерживающие методы с сервера с помощью метода HTTP-запроса OPTIONS и затем, поверх "подтверждения" с сервера, отсылали фактический запрос с фактическим методом HTTP-запроса. Сервера также могут оповещать клиентов должны ли "полномочия" (включая Cookies и HTTP Authentication данные) быть отправлены с запросом.

## **Включение CORS для API**

Допустим нам нужно разрешить работу **JavaScript** на сторонних сайтах (например, 127.0.0.1:8000) что бы получать доступ к ответам API. Для этого нам нужно включить **CORS** в заголовок ответа от сервера. Это делается на стороне сервера:

````js
app.get('/public', function(req, res) {
  res.set('Access-Control-Allow-Origin', '*')
  res.send(...)
})
````

Здесь мы устанавливаем заголовку **Access-Control-Allow-Origin** значение `*`, что означает: что любому хосту разрешен доступ к этому URL и ответу в браузере.

## **Непростые запросы и предварительные запросы (preflights)**

Предыдущий пример был так называемым простым запросом. Простые запросы — это:

* Запросы: **GET, POST**
* Тип содержимого следующего: text/plain, application/x-www-form-urlencoded, multipart/form-data

Любой заголовок, который не разрешен для простых запросов, требует предварительного запроса (preflight request).
Этот механизм позволяет веб-серверам решать, хотят ли они разрешить фактический запрос. Браузер устанавливает заголовки **Access-Control-Request-Headers** и **Access-Control-Request-Method**, чтобы сообщить серверу, какой запрос ожидать, и сервер должен ответить соответствующими заголовками.

````js
app.options('*', (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set("Access-Control-Allow-Headers", "Content-Type");
  res.send('ok');
});

app.get('/public', function(req, res) {
  res.set('Access-Control-Allow-Origin', '*')
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS')
  res.set('Access-Control-Allow-Headers', 'Content-Type')
  res.send(JSON.stringify({
    message: 'This is public info'
  }))
})
````

## **Credentials и CORS**

````js
app.get('/private', function(req, res) {
  res.set('Access-Control-Allow-Origin', 'http://127.0.0.1:8000')
  res.set('Access-Control-Allow-Credentials', 'true')
  if(req.session.loggedIn === true) {
    res.send('THIS IS THE SECRET')
  } else {
    res.send('Please login first')
  }
})
````

<http://127.0.0.1:8000> имеет доступ к приватным данным, в то время как запрос с любого другого сайта будет заблокирован.

## **Разрешить множественные источники (origin)**

````js
const ALLOWED_ORIGINS = [
  'http://home.com',
  'http://127.0.0.1:8000'
];

app.get('/private', function(req, res) {
  if(ALLOWED_ORIGINS.indexOf(req.headers.origin) > -1) {
    res.set('Access-Control-Allow-Credentials', 'true')
    res.set('Access-Control-Allow-Origin', req.headers.origin)
  } else { // разрешить другим источникам отправлять неподтвержденные запросы CORS
    res.set('Access-Control-Allow-Origin', '*')
  }
  // let caches know that the response depends on the origin
  res.set('Vary', 'Origin');
  if(req.session.loggedIn === true) {
    res.send('THIS IS THE SECRET')
  } else {
    res.send('Please login first')
  }
})
````

Не отправляйте напрямую `req.headers.origin` в качестве разрешенного заголовка **CORS**. Это позволит любому веб-сайту получить доступ к приватным данным. Из этого правила могут быть исключения, но, по крайней мере, дважды подумайте, прежде чем внедрять **CORS** с учетными данными без белого списка.

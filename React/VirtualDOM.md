# **Виртуальный DOM**

## **Ссылки**

* [виртуальный DOM](#что-такое-виртуальный-dom)
* [алгоритм сравнения](#алгоритм-сравнения)
* [fiber](#fiber)

***

## **Что такое виртуальный DOM?**

**Виртуальный DOM** (**VDOM**) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» `DOM` при помощи библиотеки, такой как `ReactDOM`. Этот процесс называется [согласованием](#алгоритм-сравнения). Такой подход и делает **API React** декларативным: вы указываете, в каком состоянии должен находиться пользовательский интерфейс, а **React** добивается, чтобы `DOM` соответствовал этому состоянию. Это абстрагирует манипуляции с атрибутами, обработку событий и ручное обновление `DOM`, которые в противном случае пришлось бы использовать при разработке приложения. Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире **React** «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, **React** также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в **React**. `VDOM` — это объектное представление `DOM`, его легковесная копия. `VDOM` содержит те же свойства, что и `DOM`, но не может напрямую влиять на то, что отображается на экране. На самом деле, `VDOM` — это обычный JavaScript-объект.

***

## **Алгоритм сравнения**

### **Согласование - reconciliation**

**React** предоставляет декларативный API, который позволяет не беспокоиться о том, что именно изменяется при каждом обновлении. При работе с **React** вы можете понимать `render()` как функцию, которая создаёт дерево React-элементов в какой-то момент времени. При последующем обновлении состояния или пропсов функция `render()` вернёт новое дерево React-элементов. Теперь **React** должен понять, как эффективно обновить UI, чтобы он совпадал с новейшим из деревьев. Существует несколько общих решений алгоритмической проблемы трансформации одного дерева в другое за минимальное количество операций.

1. **React** использует паттерн проектирования «Наблюдатель» (observer) и реагирует на изменения состояния. В **React** каждая часть UI является компонентом и почти каждый компонент имеет состояние (state). При изменении состояния компонента, **React** обновляет `VDOM`. После обновления `VDOM`, **React** сравнивает его текущую версию с предыдущей. Этот процесс называется «поиском различий» (diffing). После обнаружения объектов, изменившихся в `VDOM`, **React** обновляет соответствующие объекты в `DOM`.

2. **React** использует механизм пакетного (batch) обновления `DOM`. Этот механизм предполагает отправку обновлений в виде пакетов (набора, серии) вместо отправки отдельного обновления при каждом изменении состояния.
Повторная отрисовка UI — самая затратная часть, **React** обеспечивает точечную и групповую перерисовку `DOM`.

3. **React** использует эффективный алгоритм поиска различий. **React** использует эвристический O(n) (линейный) алгоритм, основываясь на двух предположениях:

* Два элемента разных типов приводят к построению разных деревьев
* Разработчик может обеспечить стабильность элементов между рендерингами посредством пропа key (ключ)

На практике эти предположения верны почти во всех случаях.
При сравнении двух деревьев первым делом **React** сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов.

***

### **Элементы различных типов**

Всякий раз, когда корневые элементы имеют различные типы, **React** уничтожает старое дерево и строит новое с нуля. Переходы от `<a>` к `<img>`, или от `<Article>` к `<Comment>`, или от `<Button>` к `<div>` приведут к полному перестроению. Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится:

````jsx
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
````

При этом старый `Counter` уничтожится, а новый — смонтируется.

***

### **DOM-элементы одного типа**

При сравнении двух **React** DOM-элементов одного типа, **React** смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты:

````jsx
<div className="before" title="stuff" />

<div className="after" title="stuff" />
````

Сравнивая эти элементы, **React** знает, что нужно модифицировать только `className` у лежащего в основе DOM-узла. Обновляя `style`, **React** также знает, что нужно обновлять только изменившиеся свойства:

````jsx
<div style={{color: 'red', fontWeight: 'bold'}} />

<div style={{color: 'green', fontWeight: 'bold'}} />
````

При конвертации между этими элементами, **React** знает, что нужно модифицировать только стиль `color`, а `fontWeight` сохранить. После обработки DOM-узла **React** рекурсивно проходится по дочерним элементам.
***

### **Компоненты одного типа**

Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. **React** обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает `UNSAFE_componentWillReceiveProps()`, `UNSAFE_componentWillUpdate` и `componentDidUpdate()` на базовом экземпляре. Далее вызывается метод `render()` и алгоритм сравнения рекурсивно обходит предыдущий и новый результаты.
***

### **Рекурсия по дочерним элементам**

По умолчанию при рекурсивном обходе дочерних элементов DOM-узла **React** проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично:

````jsx
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>

<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>
````

**React** сравнит два дерева `<li>первый</li>`, сравнит два дерева `<li>второй</li>`, а затем вставит дерево `<li>третий</li>`. При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например, преобразование между этими деревьями работает плохо:

````jsx
<ul>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>

<ul>
  <li>Ростов-на-Дону</li>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>
````

**React** будет мутировать каждого потомка, вместо того чтобы оставить `<li>Санкт-Петербург</li>` и `<li>Москва</li>` нетронутыми. Эта неэффективность может стать проблемой.
***

### **Ключи**

Для решения этой проблемы **React** поддерживает атрибут `key`. Когда у дочерних элементов есть ключи, **React** использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Например, если добавить `key` к неэффективному примеру выше, преобразование дерева станет эффективным:

````jsx
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
````

Теперь **React** знает, что элемент с ключом `'2014'` — новый, а элементы с ключами `'2015'` и `'2016'` только что переместились. Ключи должны быть стабильными, предсказуемыми и уникальными. Нестабильные ключи (например, произведённые с помощью Math.random()) вызовут необязательное пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних компонентов. Ключ должен быть уникальным только среди его соседей, а не глобально. В крайнем случае вы можете передать индекс элемента массива в качестве ключа. Это работает хорошо в случае, если элементы никогда не меняют порядок. Перестановки элементов вызывают замедление. При использовании ключей перестановки так же могут вызывать проблемы с состоянием компонента. Экземпляры компонента обновляются и повторно используются на основе их ключей. Перемещение элемента изменяет его, если ключ является индексом. В результате состояние компонента для таких вещей, как неуправляемые `<input>`, может смешаться и обновиться неожиданным образом. На CodePen есть примеры проблем, которые могут быть вызваны использованием индексов в качестве ключей, а также есть обновлённая версия того же примера, которая показывает как решаются проблемы с перестановкой, сортировкой и вставкой элементов в начало, если не использовать индексы как ключи.
***

### **Fiber**

**React Fiber** — прогрессивная реализация ключевого алгоритма **React**. Это кульминационное достижение двухгодичных исследований команды разработчиков **React**. Цель **Fiber** в увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов. Ее главная особенность это инкрементный рендеринг: способность разделять работу рендера на единицы и распределять их между множественными фреймами. **Fiber** – переделанная реализация алгоритма **reconciliation**. Она имеет непрямое отношение к рендерингу, в то время как механизмы рендеринга (отрисовщики) могут быть изменены чтоб поддерживать все приемущества новой архитектуры.

### **Компромиссы**

Важно помнить, что алгоритм согласования — это деталь реализации. **React** может повторно рендерить всё приложение на каждое действие, конечный результат будет тем же. Для ясности, повторный рендер в этом контексте означает вызов функции `render` для всех компонентов, но это не означает, что **React** размонтирует и смонтирует их заново. Он применит различия только следуя правилам, которые были обозначены в предыдущих разделах. **React** полагается на эвристику, следовательно, если предположения, на которых она основана, не соблюдены, пострадает производительность. Алгоритм не будет пытаться сопоставить поддеревья компонентов разных типов.
